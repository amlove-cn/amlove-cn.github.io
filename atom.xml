<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老鼠洞</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://s.amlove.cn/"/>
  <updated>2017-03-13T05:08:09.836Z</updated>
  <id>http://s.amlove.cn/</id>
  
  <author>
    <name>牵猪的仓鼠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://s.amlove.cn/2017/03/12/hello-world/"/>
    <id>http://s.amlove.cn/2017/03/12/hello-world/</id>
    <published>2017-03-12T11:45:02.000Z</published>
    <updated>2017-03-13T05:08:09.836Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      Hello world on hexo!
    
    </summary>
    
      <category term="Hexo教程" scheme="http://s.amlove.cn/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://s.amlove.cn/tags/Hexo/"/>
    
      <category term="入门" scheme="http://s.amlove.cn/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 新手记</title>
    <link href="http://s.amlove.cn/2017/03/12/Hexo-%E6%96%B0%E6%89%8B%E8%AE%B0/"/>
    <id>http://s.amlove.cn/2017/03/12/Hexo-新手记/</id>
    <published>2017-03-12T11:35:02.000Z</published>
    <updated>2017-03-13T05:03:19.653Z</updated>
    
    <content type="html"><![CDATA[<p>准备使用 hexo 来写博客</p>
<pre><code># 先安装
npm install -g hexo-cli

# 初始化博客目录
hexo init blog-dir

# 生成静态页面
hexo generate

# 本地启动
hexo server

# 部署到github
  修改 _config.yml
  deploy: 
    type: git
    repo: https://github.com/amlove-cn/amlove-cn.github.io.git
    branch: master

hexo deploy
</code></pre><h1 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h1><p><code>hexo-theme-3-hexo</code> 是个很棒的主题,要使用它,可以按以下步骤来进行:</p>
<pre><code># 安装主题
git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo

# 修改hexo根目录的_config.yml的两处，如下
theme: 3-hexo
highlight:
  enable: false #关闭hexo渲染高亮，使用主题代码块高亮

# 重新 生成
hexo g
</code></pre><h1 id="生成rss-和-sitemap"><a href="#生成rss-和-sitemap" class="headerlink" title="生成rss 和 sitemap"></a>生成rss 和 sitemap</h1><pre><code># 安装以下两个插件就可以直接生成
npm install hexo-generator-feed --save
npm install hexo-generator-sitemap --save
</code></pre><h1 id="使用标签-和-分类"><a href="#使用标签-和-分类" class="headerlink" title="使用标签 和 分类"></a>使用标签 和 分类</h1><pre><code># 标签和分类都是在文章中来指定的,通过指令去自动生成的
---
title: Hexo 新手记
date: 2017-03-12 19:35:02
categories: &quot;Hexo教程&quot; #文章分類目錄
tags: [Hexo, 入门] #文章标签
description: 搭建 Hexo 博客写作环境
---
</code></pre><h1 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h1><ul>
<li>评论服务:<br>可以使用 多说,youyan,disqus 等</li>
<li>站点统计服务:<br>百度统计,谷歌统计,不蒜子网站计数</li>
</ul>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题:"></a>遇到的问题:</h1><ul>
<li>error deployer not found:git<br>缺少插件 <code>npm install hexo-deployer-git --save</code> 的原因</li>
<li>wordcount 未定义<br>缺少插件 <code>npm install hexo-wordcount --save</code> 的原因,<a href="http://www.jianshu.com/p/e122fc6f5946" target="_blank" rel="external">参见</a></li>
<li>部署之后,CNAME被冲掉<br>解决方法就是在 <code>source</code> 目录新建一个<code>CNAME</code>文件,其中写着域名</li>
<li>文章描述出现多行该如何解决?<br>尚不知晓</li>
</ul>
]]></content>
    
    <summary type="html">
    
      搭建 Hexo 博客写作环境
    
    </summary>
    
      <category term="Hexo教程" scheme="http://s.amlove.cn/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://s.amlove.cn/tags/Hexo/"/>
    
      <category term="入门" scheme="http://s.amlove.cn/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Vim命令速查表</title>
    <link href="http://s.amlove.cn/2017/03/06/linux/Vim%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>http://s.amlove.cn/2017/03/06/linux/Vim命令速查表/</id>
    <published>2017-03-06T03:23:36.000Z</published>
    <updated>2017-03-13T04:11:01.625Z</updated>
    
    <content type="html"><![CDATA[<p>去年上半年开始全面使用linux进行开发和娱乐了，现在已经回不去windows了。</p>
<p>话归正传，在linux上一直使用vim，慢慢熟悉了它的命令，才终于领悟了什么是编辑器之神。</p>
<p>最近抽空整理了这份速查表，收获颇丰，并分享给大家。</p>
<h2 id="进入vim"><a href="#进入vim" class="headerlink" title="进入vim"></a>进入vim</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">vim filename</td>
<td style="text-align:left">打开或新建文件,并将光标置于第一行首</td>
</tr>
<tr>
<td style="text-align:left">vim +n filename</td>
<td style="text-align:left">打开文件，并将光标置于第n行首</td>
</tr>
<tr>
<td style="text-align:left">vim + filename</td>
<td style="text-align:left">打开文件，并将光标置于最后一行首</td>
</tr>
<tr>
<td style="text-align:left">vim +/pattern filename</td>
<td style="text-align:left">打开文件，并将光标置于第一个与pattern匹配的串处</td>
</tr>
<tr>
<td style="text-align:left">vim -r filename</td>
<td style="text-align:left">在上次正用vim编辑时发生系统崩溃，恢复filename</td>
</tr>
<tr>
<td style="text-align:left">vim filename….filename</td>
<td style="text-align:left">打开多个文件，依次编辑</td>
</tr>
</tbody>
</table>
<h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">all</td>
<td style="text-align:left">列出所有选项设置情况</td>
</tr>
<tr>
<td style="text-align:left">term</td>
<td style="text-align:left">设置终端类型</td>
</tr>
<tr>
<td style="text-align:left">ignorance</td>
<td style="text-align:left">在搜索中忽略大小写</td>
</tr>
<tr>
<td style="text-align:left">list</td>
<td style="text-align:left">显示制表位(Ctrl+I)和行尾标志（$)</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">显示行号</td>
</tr>
<tr>
<td style="text-align:left">report</td>
<td style="text-align:left">显示由面向行的命令修改过的数目</td>
</tr>
<tr>
<td style="text-align:left">terse</td>
<td style="text-align:left">显示简短的警告信息</td>
</tr>
<tr>
<td style="text-align:left">warn</td>
<td style="text-align:left">在转到别的文件时若没保存当前文件则显示NO write信息</td>
</tr>
<tr>
<td style="text-align:left">nomagic</td>
<td style="text-align:left">允许在搜索模式中，使用前面不带“\”的特殊字符</td>
</tr>
<tr>
<td style="text-align:left">nowrapscan</td>
<td style="text-align:left">禁止vi在搜索到达文件两端时，又从另一端开始</td>
</tr>
<tr>
<td style="text-align:left">mesg</td>
<td style="text-align:left">允许vi显示其他用户用write写到自己终端上的信息</td>
</tr>
<tr>
<td style="text-align:left">:set number / set nonumber</td>
<td style="text-align:left">显示/不显示行号</td>
</tr>
<tr>
<td style="text-align:left">:set ruler /set noruler</td>
<td style="text-align:left">显示/不显示标尺</td>
</tr>
<tr>
<td style="text-align:left">:set hlsearch</td>
<td style="text-align:left">高亮显示查找到的单词</td>
</tr>
<tr>
<td style="text-align:left">:set nohlsearch</td>
<td style="text-align:left">关闭高亮显示</td>
</tr>
<tr>
<td style="text-align:left">:syntax on</td>
<td style="text-align:left">语法高亮</td>
</tr>
<tr>
<td style="text-align:left">:set nu</td>
<td style="text-align:left">显示行号</td>
</tr>
<tr>
<td style="text-align:left">:set tabstop=8</td>
<td style="text-align:left">设置tab大小,8为最常用最普遍的设置</td>
</tr>
<tr>
<td style="text-align:left">:set softtabstop=8</td>
<td style="text-align:left">4:4个空格,8:正常的制表符,12:一个制表符4个空格,16:两个制表符</td>
</tr>
<tr>
<td style="text-align:left">:set autoindent</td>
<td style="text-align:left">自动缩进</td>
</tr>
<tr>
<td style="text-align:left">:set cindent</td>
<td style="text-align:left">C语言格式里面的自动缩进</td>
</tr>
</tbody>
</table>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">k nk</td>
<td style="text-align:left">上 向上移动n行</td>
</tr>
<tr>
<td style="text-align:left">j nj</td>
<td style="text-align:left">下 向下移动n行</td>
</tr>
<tr>
<td style="text-align:left">h nh</td>
<td style="text-align:left">左 向左移动n行</td>
</tr>
<tr>
<td style="text-align:left">l nl</td>
<td style="text-align:left">右 向右移动n行</td>
</tr>
<tr>
<td style="text-align:left">Space</td>
<td style="text-align:left">光标右移一个字符</td>
</tr>
<tr>
<td style="text-align:left">Backspace</td>
<td style="text-align:left">光标左移一个字符</td>
</tr>
<tr>
<td style="text-align:left">Enter</td>
<td style="text-align:left">光标下移一行</td>
</tr>
<tr>
<td style="text-align:left">w/W</td>
<td style="text-align:left">光标右移一个字至字首</td>
</tr>
<tr>
<td style="text-align:left">b/B</td>
<td style="text-align:left">光标左移一个字至字首</td>
</tr>
<tr>
<td style="text-align:left">e或E</td>
<td style="text-align:left">光标右移一个字至字尾</td>
</tr>
<tr>
<td style="text-align:left">)</td>
<td style="text-align:left">光标移至句尾</td>
</tr>
<tr>
<td style="text-align:left">(</td>
<td style="text-align:left">光标移至句首</td>
</tr>
<tr>
<td style="text-align:left">}</td>
<td style="text-align:left">光标移至段落开头</td>
</tr>
<tr>
<td style="text-align:left">{</td>
<td style="text-align:left">光标移至段落结尾</td>
</tr>
<tr>
<td style="text-align:left">n$</td>
<td style="text-align:left">光标移至第n行尾</td>
</tr>
<tr>
<td style="text-align:left">H</td>
<td style="text-align:left">光标移至屏幕顶行</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td style="text-align:left">光标移至屏幕中间行</td>
</tr>
<tr>
<td style="text-align:left">L</td>
<td style="text-align:left">光标移至屏幕最后行</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">（注意是数字零）光标移至当前行首</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">移动光标到行首第一个非空字符上去</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">光标移至当前行尾</td>
</tr>
<tr>
<td style="text-align:left">gg</td>
<td style="text-align:left">移到第一行</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td style="text-align:left">移到最后一行</td>
</tr>
<tr>
<td style="text-align:left">f<a></a></td>
<td style="text-align:left">移动光标到当前行的字符a上</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td style="text-align:left">相反</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">移动到与制匹配的括号上去（），{}，[]，&lt;&gt;等</td>
</tr>
<tr>
<td style="text-align:left">nG</td>
<td style="text-align:left">移动到第n行上</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td style="text-align:left">到最后一行</td>
</tr>
</tbody>
</table>
<h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl+u</td>
<td style="text-align:left">向文件首翻半屏</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+d</td>
<td style="text-align:left">向文件尾翻半屏</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+f</td>
<td style="text-align:left">向文件尾翻一屏</td>
</tr>
<tr>
<td style="text-align:left">Ctrl＋b</td>
<td style="text-align:left">向文件首翻一屏</td>
</tr>
<tr>
<td style="text-align:left">nz</td>
<td style="text-align:left">将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部</td>
</tr>
</tbody>
</table>
<h2 id="插入文本类"><a href="#插入文本类" class="headerlink" title="插入文本类"></a>插入文本类</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">在光标前</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">在当前行首</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">光标后</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">在当前行尾</td>
</tr>
<tr>
<td style="text-align:left">o</td>
<td style="text-align:left">在当前行之下新开一行</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">在当前行之上新开一行</td>
</tr>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">替换当前字符</td>
</tr>
<tr>
<td style="text-align:left">R</td>
<td style="text-align:left">替换当前字符及其后的字符，直至按ESC键</td>
</tr>
<tr>
<td style="text-align:left">s</td>
<td style="text-align:left">从当前光标位置处开始，以输入的文本替代指定数目的字符</td>
</tr>
<tr>
<td style="text-align:left">S</td>
<td style="text-align:left">删除指定数目的行，并以所输入文本代替之</td>
</tr>
<tr>
<td style="text-align:left">ncw/nCW</td>
<td style="text-align:left">修改指定数目的字</td>
</tr>
<tr>
<td style="text-align:left">nCC</td>
<td style="text-align:left">修改指定数目的行</td>
</tr>
</tbody>
</table>
<h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x/X</td>
<td style="text-align:left">删除一个字符，x删除光标后的，而X删除光标前的</td>
</tr>
<tr>
<td style="text-align:left">dw</td>
<td style="text-align:left">删除一个单词(删除光标位置到下一个单词开始的位置)</td>
</tr>
<tr>
<td style="text-align:left">dnw</td>
<td style="text-align:left">删除n个单词</td>
</tr>
<tr>
<td style="text-align:left">dne</td>
<td style="text-align:left">也可，只是删除到单词尾</td>
</tr>
<tr>
<td style="text-align:left">do</td>
<td style="text-align:left">删至行首</td>
</tr>
<tr>
<td style="text-align:left">d$</td>
<td style="text-align:left">删至行尾</td>
</tr>
<tr>
<td style="text-align:left">dd</td>
<td style="text-align:left">删除一行</td>
</tr>
<tr>
<td style="text-align:left">ndd</td>
<td style="text-align:left">删除当前行及其后n-1行</td>
</tr>
<tr>
<td style="text-align:left">dnl</td>
<td style="text-align:left">向右删除n个字母</td>
</tr>
<tr>
<td style="text-align:left">dnh</td>
<td style="text-align:left">向左删除n个字母</td>
</tr>
<tr>
<td style="text-align:left">dnj</td>
<td style="text-align:left">向下删除n行,当前行+其上n行</td>
</tr>
<tr>
<td style="text-align:left">dnk</td>
<td style="text-align:left">向上删除n行,当期行+其下n行</td>
</tr>
<tr>
<td style="text-align:left">cnw[word]</td>
<td style="text-align:left">将n个word改变为word</td>
</tr>
<tr>
<td style="text-align:left">C$</td>
<td style="text-align:left">改变到行尾</td>
</tr>
<tr>
<td style="text-align:left">cc</td>
<td style="text-align:left">改变整行</td>
</tr>
<tr>
<td style="text-align:left">shift+j</td>
<td style="text-align:left">删除行尾的换行符，下一行接上来了</td>
</tr>
</tbody>
</table>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴用x或d删除的文本</td>
</tr>
<tr>
<td style="text-align:left">ynw</td>
<td style="text-align:left">复制n个单词</td>
</tr>
<tr>
<td style="text-align:left">yy</td>
<td style="text-align:left">复制一行</td>
</tr>
<tr>
<td style="text-align:left">ynl</td>
<td style="text-align:left">复制n个字符</td>
</tr>
<tr>
<td style="text-align:left">y$</td>
<td style="text-align:left">复制当前光标至行尾处</td>
</tr>
<tr>
<td style="text-align:left">nyy</td>
<td style="text-align:left">拷贝n行</td>
</tr>
</tbody>
</table>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">撤销前一次的操作</td>
</tr>
<tr>
<td style="text-align:left">shif+u(U)</td>
<td style="text-align:left">撤销对该行的所有操作</td>
</tr>
</tbody>
</table>
<h2 id="搜索及替换"><a href="#搜索及替换" class="headerlink" title="搜索及替换"></a>搜索及替换</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/pattern</td>
<td style="text-align:left">从光标开始处向文件尾搜索pattern</td>
</tr>
<tr>
<td style="text-align:left">?pattern</td>
<td style="text-align:left">从光标开始处向文件首搜索pattern</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left">在同一方向重复上一次搜索命令</td>
</tr>
<tr>
<td style="text-align:left">N</td>
<td style="text-align:left">在反方向上重复上一次搜索命令</td>
</tr>
<tr>
<td style="text-align:left">cw newword</td>
<td style="text-align:left">替换为newword</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left">继续查找</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">执行替换</td>
</tr>
<tr>
<td style="text-align:left">:s/p1/p2/g</td>
<td style="text-align:left">将当前行中所有p1均用p2替代,g表示执行 用c表示需要确认</td>
</tr>
<tr>
<td style="text-align:left">:n1,n2 s/p1/p2/g</td>
<td style="text-align:left">将第n1至n2行中所有p1均用p2替代</td>
</tr>
<tr>
<td style="text-align:left">:g/p1/s//p2/g</td>
<td style="text-align:left">将文件中所有p1均用p2替换</td>
</tr>
<tr>
<td style="text-align:left">:1,$ s/string1/string2/g</td>
<td style="text-align:left">在全文中将string1替换为string2</td>
</tr>
</tbody>
</table>
<h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">m[a-z]</td>
<td style="text-align:left">在文中做标记，标记号可为a-z的26个字母</td>
</tr>
<tr>
<td style="text-align:left">`a</td>
<td style="text-align:left">移动到标记a处</td>
</tr>
</tbody>
</table>
<h2 id="visual模式"><a href="#visual模式" class="headerlink" title="visual模式"></a>visual模式</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">v</td>
<td style="text-align:left">进入visual 模式</td>
</tr>
<tr>
<td style="text-align:left">V</td>
<td style="text-align:left">进入行的visual 模式</td>
</tr>
<tr>
<td style="text-align:left">ctrl+v</td>
<td style="text-align:left">进如块操作模式用o和O改变选择的边的大小</td>
</tr>
<tr>
<td style="text-align:left">在所有行插入相同的内容如include&lt;</td>
<td style="text-align:left">将光标移到开始插入的位置，按CTRL+V进入VISUAL模式，选择好模块后按I（shift+i)，后插入要插入的文本，按[ESC]完成</td>
</tr>
</tbody>
</table>
<h2 id="行方式命令"><a href="#行方式命令" class="headerlink" title="行方式命令"></a>行方式命令</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:n1,n2 co n3</td>
<td style="text-align:left">将n1行到n2行之间的内容拷贝到第n3行下</td>
</tr>
<tr>
<td style="text-align:left">:n1,n2 m n3</td>
<td style="text-align:left">将n1行到n2行之间的内容移至到第n3行下</td>
</tr>
<tr>
<td style="text-align:left">:n1,n2 d</td>
<td style="text-align:left">将n1行到n2行之间的内容删除</td>
</tr>
<tr>
<td style="text-align:left">:n1,n2 w!command</td>
<td style="text-align:left">将文件中n1行至n2行的内容作为command的输入并执行之<br>若不指定n1，n2，则表示将整个文件内容作为command的输入</td>
</tr>
</tbody>
</table>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">q[a-z]</td>
<td style="text-align:left">开始记录但前开始的操作为宏，名称可为【a-z】，然后用q终止录制宏</td>
</tr>
<tr>
<td style="text-align:left">reg</td>
<td style="text-align:left">显示当前定义的所有的宏，用@[a-z]来在当前光标处执行宏[a-z]</td>
</tr>
</tbody>
</table>
<h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:split</td>
<td style="text-align:left">分割一个窗口</td>
</tr>
<tr>
<td style="text-align:left">:split file.c</td>
<td style="text-align:left">为另一个文件file.c分隔窗口</td>
</tr>
<tr>
<td style="text-align:left">:nsplit file.c</td>
<td style="text-align:left">为另一个文件file.c分隔窗口，并指定其行数</td>
</tr>
<tr>
<td style="text-align:left">ctrl＋w</td>
<td style="text-align:left">在窗口中切换</td>
</tr>
<tr>
<td style="text-align:left">:close</td>
<td style="text-align:left">关闭当前窗口</td>
</tr>
</tbody>
</table>
<h2 id="文件及其他"><a href="#文件及其他" class="headerlink" title="文件及其他"></a>文件及其他</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:q</td>
<td style="text-align:left">退出vi</td>
</tr>
<tr>
<td style="text-align:left">:q!</td>
<td style="text-align:left">不保存文件并退出vi</td>
</tr>
<tr>
<td style="text-align:left">:e filename</td>
<td style="text-align:left">打开文件filename进行编辑</td>
</tr>
<tr>
<td style="text-align:left">:e!</td>
<td style="text-align:left">放弃修改文件内容，重新载入该文件编辑</td>
</tr>
<tr>
<td style="text-align:left">:w</td>
<td style="text-align:left">保存当前文件</td>
</tr>
<tr>
<td style="text-align:left">:wq</td>
<td style="text-align:left">存盘退出</td>
</tr>
<tr>
<td style="text-align:left">:ZZ</td>
<td style="text-align:left">保存当前文档并退出VIM</td>
</tr>
<tr>
<td style="text-align:left">:!command</td>
<td style="text-align:left">执行shell命令command</td>
</tr>
<tr>
<td style="text-align:left">:r!command</td>
<td style="text-align:left">将命令command的输出结果放到当前行</td>
</tr>
<tr>
<td style="text-align:left">:n1,n2 write temp.c</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">:read file.c</td>
<td style="text-align:left">将文件file.c的内容插入到当前光标所在的下面</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年上半年开始全面使用linux进行开发和娱乐了，现在已经回不去windows了。&lt;/p&gt;
&lt;p&gt;话归正传，在linux上一直使用vim，慢慢熟悉了它的命令，才终于领悟了什么是编辑器之神。&lt;/p&gt;
&lt;p&gt;最近抽空整理了这份速查表，收获颇丰，并分享给大家。&lt;/p&gt;
&lt;h2 i
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="vim" scheme="http://s.amlove.cn/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>如何在linux中搭建ftp服务</title>
    <link href="http://s.amlove.cn/2017/03/06/linux/%E5%A6%82%E4%BD%95%E5%9C%A8linux%E4%B8%AD%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/"/>
    <id>http://s.amlove.cn/2017/03/06/linux/如何在linux中搭建ftp服务/</id>
    <published>2017-03-06T00:47:48.000Z</published>
    <updated>2017-03-13T04:11:01.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-FTP"><a href="#什么是-FTP" class="headerlink" title="什么是 FTP"></a>什么是 FTP</h2><p><code>FTP</code> 是文件传输协议File Transfer Protocol的缩写。顾名思义，FTP用于计算机之间通过网络进行文件传输。你可以通过FTP在计算机账户间进行文件传输，也可以在账户和桌面计算机之间传输文件，或者访问在线软件归档。但是，需要注意的是多数的FTP站点的使用率非常高，可能需要多次重连才能连接上。</p>
<p>FTP地址和HTTP地址（即网页地址）非常相似，只是FTP地址使用 <code>ftp://前缀而不是http://</code></p>
<h2 id="FTP-服务器是什么"><a href="#FTP-服务器是什么" class="headerlink" title="FTP 服务器是什么"></a>FTP 服务器是什么</h2><p>通常，拥有FTP地址的计算机是专用于接收FTP连接请求的。一台专用于接收FTP连接请求的计算机即为FTP服务器或者FTP站点。</p>
<p>现在，我们来开始一个特别的冒险，我们将会搭建一个FTP服务用于和家人、朋友进行文件共享。在本教程，我们将以vsftpd作为ftp服务。</p>
<p>VSFTPD是一个自称为最安全的FTP服务端软件。事实上VSFTPD的前两个字母表示“非常安全的very secure”。该软件的构建绕开了FTP协议的漏洞。</p>
<p>尽管如此，你应该知道还有更安全的方法进行文件管理和传输，如：SFTP（使用OpenSSH）。FTP协议对于共享非敏感数据是非常有用和可靠的。</p>
<h2 id="安装-VSFTP"><a href="#安装-VSFTP" class="headerlink" title="安装 VSFTP"></a>安装 VSFTP</h2><pre><code class="bash">#使用 rpm 安装
$ dnf -y install vsftpd
#使用 deb 安装
$ sudo apt-get install vsftpd
#在 Arch 中安装
$ sudo pacman -S vsftpd
</code></pre>
<h2 id="配置-FTP-服务"><a href="#配置-FTP-服务" class="headerlink" title="配置 FTP 服务"></a>配置 FTP 服务</h2><p>多数的VSFTPD配置项都在/etc/vsftpd.conf配置文件中。这个文件本身已经有非常良好的文档说明了，因此，在本节中，我只强调一些你可能进行修改的重要选项。使用man页面查看所有可用的选项和基本的 文档说明：</p>
<pre><code class="bash">$ man vsftpd.conf
</code></pre>
<p>根据文件系统层级标准，FTP共享文件默认位于/srv/ftp目录中。<br><strong>允许上传：</strong><br>为了允许ftp用户可以修改文件系统的内容，如上传文件等，“write_enable”标志必须设置为 YES</p>
<pre><code class="xml">write_enable=YES
</code></pre>
<p><strong>允许本地（系统）用户登录：</strong><br>为了允许文件/etc/passwd中记录的用户可以登录ftp服务，“local_enable”标记必须设置为YES。</p>
<pre><code class="xml">local_enable=YES
</code></pre>
<p><strong>匿名用户登录</strong><br>下面配置内容控制匿名用户是否允许登录：</p>
<pre><code class="xml"># 允许匿名用户登录
anonymous_enable=YES
# 匿名登录不需要密码（可选）
no_anon_password=YES
# 匿名登录的最大传输速率，Bytes/second（可选）
anon_max_rate=30000
# 匿名登录的目录（可选）
anon_root=/example/directory/
</code></pre>
<p><strong>根目录限制（Chroot Jail）</strong><br>（ LCTT 译注：chroot jail是类unix系统中的一种安全机制，用于修改进程运行的根目录环境，限制该线程不能感知到其根目录树以外的其他目录结构和文件的存在。详情参看<a href="https://zh.wikipedia.org/wiki/Chroot" target="_blank" rel="external">chroot jail</a>）</p>
<p>有时我们需要设置根目录（chroot）环境来禁止用户离开他们的家（home）目录。在配置文件中增加/修改下面配置开启根目录限制（Chroot Jail）:</p>
<pre><code class="xml">chroot_list_enable=YES
chroot_list_file=/etc/vsftpd.chroot_list
</code></pre>
<p>“chroot_list_file”变量指定根目录限制所包含的文件/目录（ LCTT 译注：即用户只能访问这些文件/目录）</p>
<p>最后你必须重启ftp服务，在命令行中输入以下命令：</p>
<pre><code class="bash">$ sudo systemctl restart vsftpd
</code></pre>
<p>到此为止，你的ftp服务已经搭建完成并且启动了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-FTP&quot;&gt;&lt;a href=&quot;#什么是-FTP&quot; class=&quot;headerlink&quot; title=&quot;什么是 FTP&quot;&gt;&lt;/a&gt;什么是 FTP&lt;/h2&gt;&lt;p&gt;&lt;code&gt;FTP&lt;/code&gt; 是文件传输协议File Transfer Protocol的缩写。
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="ftp" scheme="http://s.amlove.cn/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（57）: sftp命令</title>
    <link href="http://s.amlove.cn/2017/03/05/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8857%EF%BC%89-sftp%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/03/05/linux/每天一个linux命令（57）-sftp命令/</id>
    <published>2017-03-05T08:29:38.000Z</published>
    <updated>2017-03-13T04:11:01.652Z</updated>
    
    <content type="html"><![CDATA[<p>sFTP（安全文件传输程序）是一种安全的交互式文件传输程序，其工作方式与 FTP（文件传输协议）类似。 然而，sFTP 比 FTP 更安全；它通过加密 SSH 传输处理所有操作。</p>
<p>它可以配置使用几个有用的 SSH 功能，如公钥认证和压缩。 它连接并登录到指定的远程机器，然后切换到交互式命令模式，在该模式下用户可以执行各种命令。</p>
<p>在本文中，我们将向你展示如何使用 sFTP 上传/下载整个目录（包括其子目录和子文件）。</p>
<h2 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h2><p>默认情况下，SFTP 协议采用和 SSH 传输协议一样的方式建立到远程服务器的安全连接。虽然，用户验证使用类似于 SSH 默认设置的密码方式，但是，建议创建和使用 SSH 无密码登录，以简化和更安全地连接到远程主机。</p>
<p>要连接到远程 sftp 服务器，如下建立一个安全 SSH 连接并创建 SFTP 会话：</p>
<pre><code class="bash">$ sftp root@server
</code></pre>
<p>登录到远程主机后，你可以如下运行交互式的 sFTP 命令：</p>
<pre><code class="bash">sftp&gt; ls            #列出服务器文件列表
sftp&gt; lls           #列出本地文件列表
sftp&gt; pwd           #当前服务器上路径
sftp&gt; lpwd          #当前本地路径
sftp&gt; cd img        #切换服务器路径
sftp&gt; lcd img       #切换本地路径
sftp&gt; mkdir img     #在服务器上创建一个目录
sftp&gt; lmkdir img    #在本地创建一个目录
</code></pre>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><pre><code class="bash">sftp&gt; put readme.md #上传单个文件
sftp&gt; mput *.xls    #上传多个文件
</code></pre>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><pre><code class="bash">sftp&gt; get readme.md #下载单个文件
sftp&gt; mget *.xls    #下载多个文件
</code></pre>
<h2 id="上传文件夹"><a href="#上传文件夹" class="headerlink" title="上传文件夹"></a>上传文件夹</h2><p>使用<code>put -r</code> .但是远程服务器要提前创建一个相同名称的目录; <code>-r</code> 递归复制子目录和子文件</p>
<pre><code class="bash">sftp&gt; mkdir img
sftp&gt; put -r img
</code></pre>
<p>要保留修改时间、访问时间以及被传输的文件的模式，可使用 <code>-p</code> 。</p>
<pre><code class="bash">sftp&gt; put -pr img
</code></pre>
<h2 id="下载文件夹"><a href="#下载文件夹" class="headerlink" title="下载文件夹"></a>下载文件夹</h2><pre><code class="bash">sftp&gt; get -r img
</code></pre>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><pre><code class="bash">sftp&gt; bye
或
sftp&gt; exit
或
ctrl + d
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sFTP（安全文件传输程序）是一种安全的交互式文件传输程序，其工作方式与 FTP（文件传输协议）类似。 然而，sFTP 比 FTP 更安全；它通过加密 SSH 传输处理所有操作。&lt;/p&gt;
&lt;p&gt;它可以配置使用几个有用的 SSH 功能，如公钥认证和压缩。 它连接并登录到指定的
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（56）: tailf命令</title>
    <link href="http://s.amlove.cn/2017/02/20/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8856%EF%BC%89-tailf%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/02/20/linux/每天一个linux命令（56）-tailf命令/</id>
    <published>2017-02-20T07:11:06.000Z</published>
    <updated>2017-03-13T04:11:01.651Z</updated>
    
    <content type="html"><![CDATA[<p>　　tailf 一个实时监听文件或日志的强大的命令<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ tailf [option] file
</code></pre>
<h3 id="命令描述"><a href="#命令描述" class="headerlink" title="命令描述"></a>命令描述</h3><p>　　tailf 将会打印出一个文件的最后10行,等待并持续输出此文件的增长，它和<code>tail -f</code>相似，不同之处是当文件没有增长时，是不访问此文件的；但这会有一个副作用：不会更新文件的访问时间。当没有发生日志活动时，文件系统的冲洗（flush）不会定期发生。<br>　　tailf 对于打印日志不频繁，而又在使用笔记本电脑时是非常有用的，这样用户就能降低磁盘转速从而增加笔记本续航。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-n,–lines=N,-N</td>
<td style="text-align:left">输出最后N行,而不是默认的最后10行</td>
</tr>
</tbody>
</table>
<h3 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h3><p><strong><code>例一</code>：展示一个文件的最后5行并监听文件的新行（新增加的内容）</strong></p>
<pre><code class="bash">$ tailf -n 5 myfile.txt
$ tailf -5 myfile.txt
$ tailf --lines=5 myfile.txt
</code></pre>
<blockquote>
<p><code>注：</code>这是一个实时监听文件或日志的强大的命令</p>
</blockquote>
<p><strong><code>例二</code>：实时新增日志内容，并通过管道过滤出自己想要的内容</strong></p>
<pre><code class="bash"># 实时监听ip地址为24.10.160.10的访问日志
$ tailf access.log | grep 24.10.160.10
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　tailf 一个实时监听文件或日志的强大的命令&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令</title>
    <link href="http://s.amlove.cn/2017/01/23/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/23/linux/每天一个linux命令/</id>
    <published>2017-01-23T03:41:48.000Z</published>
    <updated>2017-03-13T11:25:30.975Z</updated>
    
    <content type="html"><![CDATA[<p>开始详细的系统的学习linux命令，坚持每天一个命令。<br>此专题下的<code>每天一个linux命令</code>来源于 yelog.<br><a id="more"></a><br>此系列最初参考<a href="http://www.cnblogs.com/peida/archive/2012/12/05/2803591.html" target="_blank" rel="external">peida</a>的“每天一个linux命令”，之后根据自己的见闻逐渐添加整理。</p>
<h3 id="文件目录操作命令"><a href="#文件目录操作命令" class="headerlink" title="文件目录操作命令"></a>文件目录操作命令</h3><ol>
<li><a href="/2016/12/01/linux/每天一个linux命令（1）-ls命令/" title="每天一个linux命令（1）: ls命令">每天一个linux命令（1）: ls命令</a></li>
<li><a href="/2016/12/02/linux/每天一个linux命令（2）-cd命令/" title="每天一个linux命令（2）: cd命令">每天一个linux命令（2）: cd命令</a></li>
<li><a href="/2016/12/03/linux/每天一个linux命令（3）-pwd命令/" title="每天一个linux命令（3）: pwd命令">每天一个linux命令（3）: pwd命令</a></li>
<li><a href="/2016/12/04/linux/每天一个linux命令（4）-mkdir命令/" title="每天一个linux命令（4）: mkdir命令">每天一个linux命令（4）: mkdir命令</a></li>
<li><a href="/2016/12/05/linux/每天一个linux命令（5）-rm命令/" title="每天一个linux命令（5）: rm命令">每天一个linux命令（5）: rm命令</a></li>
<li><a href="/2016/12/06/linux/每天一个linux命令（6）-rmdir命令/" title="每天一个linux命令（6）: rmdir命令">每天一个linux命令（6）: rmdir命令</a></li>
<li><a href="/2016/12/07/linux/每天一个linux命令（7）-mv命令/" title="每天一个linux命令（7）: mv命令">每天一个linux命令（7）: mv命令</a></li>
<li><a href="/2016/12/08/linux/每天一个linux命令（8）-cp命令/" title="每天一个linux命令（8）: cp命令">每天一个linux命令（8）: cp命令</a></li>
<li><a href="/2016/12/09/linux/每天一个linux命令（9）-touch命令/" title="每天一个linux命令（9）: touch命令">每天一个linux命令（9）: touch命令</a></li>
<li><a href="/2016/12/10/linux/每天一个linux命令（10）-cat命令/" title="每天一个linux命令（10）: cat命令">每天一个linux命令（10）: cat命令</a></li>
<li><a href="/2016/12/11/linux/每天一个linux命令（11）-nl命令/" title="每天一个linux命令（11）: nl命令">每天一个linux命令（11）: nl命令</a></li>
<li><a href="/2016/12/12/linux/每天一个linux命令（12）-more命令/" title="每天一个linux命令（12）: more命令">每天一个linux命令（12）: more命令</a></li>
<li><a href="/2016/12/13/linux/每天一个linux命令（13）-less命令/" title="每天一个linux命令（13）: less命令">每天一个linux命令（13）: less命令</a></li>
<li><a href="/2016/12/14/linux/每天一个linux命令（14）-head命令/" title="每天一个linux命令（14）: head命令">每天一个linux命令（14）: head命令</a></li>
<li><a href="/2016/12/15/linux/每天一个linux命令（15）-tail命令/" title="每天一个linux命令（15）: tail命令">每天一个linux命令（15）: tail命令</a></li>
<li><a href="/2017/02/20/linux/每天一个linux命令（56）-tailf命令/" title="每天一个linux命令（56）: tailf命令">每天一个linux命令（56）: tailf命令</a>
</li>
</ol>
<h3 id="文件查找命令"><a href="#文件查找命令" class="headerlink" title="文件查找命令"></a>文件查找命令</h3><ol>
<li><a href="/2016/12/16/linux/每天一个linux命令（16）-which命令/" title="每天一个linux命令（16）: which命令">每天一个linux命令（16）: which命令</a></li>
<li><a href="/2016/12/17/linux/每天一个linux命令（17）-whereis命令/" title="每天一个linux命令（17）: whereis命令">每天一个linux命令（17）: whereis命令</a></li>
<li><a href="/2016/12/18/linux/每天一个linux命令（18）-locate命令/" title="每天一个linux命令（18）: locate命令">每天一个linux命令（18）: locate命令</a></li>
<li><a href="/2016/12/19/linux/每天一个linux命令（19）-find命令概览/" title="每天一个linux命令（19）: find命令概览">每天一个linux命令（19）: find命令概览</a></li>
<li><a href="/2016/12/20/linux/每天一个linux命令（20）-find命令之exec/" title="每天一个linux命令（20）: find命令之exec">每天一个linux命令（20）: find命令之exec</a></li>
<li><a href="/2016/12/21/linux/每天一个linux命令（21）-find命令之xargs/" title="每天一个linux命令（21）: find命令之xargs">每天一个linux命令（21）: find命令之xargs</a></li>
<li><a href="/2016/12/22/linux/每天一个linux命令（22）-find命令的参数详解/" title="每天一个linux命令（22）: find命令的参数详解">每天一个linux命令（22）: find命令的参数详解</a>
</li>
</ol>
<h3 id="文件打包上传和下载"><a href="#文件打包上传和下载" class="headerlink" title="文件打包上传和下载"></a>文件打包上传和下载</h3><ol>
<li><a href="/2016/12/23/linux/每天一个linux命令（23）-用SecureCRT来上传和下载文件/" title="每天一个linux命令（23）: 用SecureCRT来上传和下载文件">每天一个linux命令（23）: 用SecureCRT来上传和下载文件</a></li>
<li><a href="/2016/12/24/linux/每天一个linux命令（24）-tar命令/" title="每天一个linux命令（24）: tar命令">每天一个linux命令（24）: tar命令</a></li>
<li><a href="/2016/12/25/linux/每天一个linux命令（25）-gzip命令/" title="每天一个linux命令（25）: gzip命令">每天一个linux命令（25）: gzip命令</a>
</li>
</ol>
<h3 id="linux文件权限设置"><a href="#linux文件权限设置" class="headerlink" title="linux文件权限设置"></a>linux文件权限设置</h3><ol>
<li><a href="/2016/12/26/linux/每天一个linux命令（26）-chmod命令/" title="每天一个linux命令（26）: chmod命令">每天一个linux命令（26）: chmod命令</a></li>
<li><a href="/2016/12/27/linux/每天一个linux命令（27）-chgrp命令/" title="每天一个linux命令（27）: chgrp命令">每天一个linux命令（27）: chgrp命令</a></li>
<li><a href="/2016/12/28/linux/每天一个linux命令（28）-chown命令/" title="每天一个linux命令（28）: chown命令">每天一个linux命令（28）: chown命令</a></li>
<li><a href="/2016/12/29/linux/每天一个linux命令（29）-etc-group文件详解/" title="每天一个linux命令（29）: /etc/group文件详解">每天一个linux命令（29）: /etc/group文件详解</a>
</li>
</ol>
<h3 id="磁盘存储相关"><a href="#磁盘存储相关" class="headerlink" title="磁盘存储相关"></a>磁盘存储相关</h3><ol>
<li><a href="/2016/12/30/linux/每天一个linux命令（30）-df命令/" title="每天一个linux命令（30）: df命令">每天一个linux命令（30）: df命令</a></li>
<li><a href="/2016/12/31/linux/每天一个linux命令（31）-du命令/" title="每天一个linux命令（31）: du命令">每天一个linux命令（31）: du命令</a>
</li>
</ol>
<h3 id="性能监控和优化命令"><a href="#性能监控和优化命令" class="headerlink" title="性能监控和优化命令"></a>性能监控和优化命令</h3><ol>
<li><a href="/2017/01/01/linux/每天一个linux命令（32）-top命令/" title="每天一个linux命令（32）: top命令">每天一个linux命令（32）: top命令</a></li>
<li><a href="/2017/01/02/linux/每天一个linux命令（33）-free命令/" title="每天一个linux命令（33）: free命令">每天一个linux命令（33）: free命令</a></li>
<li><a href="/2017/01/03/linux/每天一个linux命令（34）-vmstat命令/" title="每天一个linux命令（34）: vmstat命令">每天一个linux命令（34）: vmstat命令</a></li>
<li><a href="/2017/01/04/linux/每天一个linux命令（35）-iostat命令/" title="每天一个linux命令（35）: iostat命令">每天一个linux命令（35）: iostat命令</a></li>
<li><a href="/2017/01/05/linux/每天一个linux命令（36）-lsof命令/" title="每天一个linux命令（36）: lsof命令">每天一个linux命令（36）: lsof命令</a>
</li>
</ol>
<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><ol>
<li><a href="/2017/01/06/linux/每天一个linux命令（37）-ifconfig命令/" title="每天一个linux命令（37）: ifconfig命令">每天一个linux命令（37）: ifconfig命令</a></li>
<li><a href="/2017/01/07/linux/每天一个linux命令（38）-route命令/" title="每天一个linux命令（38）: route命令">每天一个linux命令（38）: route命令</a></li>
<li><a href="/2017/01/08/linux/每天一个linux命令（39）-ping命令/" title="每天一个linux命令（39）: ping命令">每天一个linux命令（39）: ping命令</a></li>
<li><a href="/2017/01/09/linux/每天一个linux命令（40）-traceroute命令/" title="每天一个linux命令（40）: traceroute命令">每天一个linux命令（40）: traceroute命令</a></li>
<li><a href="/2017/01/10/linux/每天一个linux命令（41）-netstat命令/" title="每天一个linux命令（41）: netstat命令">每天一个linux命令（41）: netstat命令</a></li>
<li><a href="/2017/01/11/linux/每天一个linux命令（42）-ss命令/" title="每天一个linux命令（42）: ss命令">每天一个linux命令（42）: ss命令</a></li>
<li><a href="/2017/01/12/linux/每天一个linux命令（43）-telnet命令/" title="每天一个linux命令（43）: telnet命令">每天一个linux命令（43）: telnet命令</a></li>
<li><a href="/2017/01/12/linux/每天一个linux命令（44）-rcp命令/" title="每天一个linux命令（44）: rcp命令">每天一个linux命令（44）: rcp命令</a></li>
<li><a href="/2017/01/13/linux/每天一个linux命令（45）-scp命令/" title="每天一个linux命令（45）: scp命令">每天一个linux命令（45）: scp命令</a>
</li>
</ol>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ol>
<li><a href="/2017/01/14/linux/每天一个linux命令（46）-ln命令/" title="每天一个linux命令（46）: ln命令">每天一个linux命令（46）: ln命令</a></li>
<li><a href="/2017/01/15/linux/每天一个linux命令（47）-diff命令/" title="每天一个linux命令（47）: diff命令">每天一个linux命令（47）: diff命令</a></li>
<li><a href="/2017/01/16/linux/每天一个linux命令（48）-date命令/" title="每天一个linux命令（48）: date命令">每天一个linux命令（48）: date命令</a></li>
<li><a href="/2017/01/17/linux/每天一个linux命令（49）-cal命令/" title="每天一个linux命令（49）: cal命令">每天一个linux命令（49）: cal命令</a></li>
<li><a href="/2017/01/18/linux/每天一个linux命令（50）-grep命令/" title="每天一个linux命令（50）: grep命令">每天一个linux命令（50）: grep命令</a></li>
<li><a href="/2017/01/19/linux/每天一个linux命令（51）-wc命令/" title="每天一个linux命令（51）: wc命令">每天一个linux命令（51）: wc命令</a></li>
<li><a href="/2017/01/20/linux/每天一个linux命令（52）-ps命令/" title="每天一个linux命令（52）: ps命令">每天一个linux命令（52）: ps命令</a></li>
<li><a href="/2017/01/21/linux/每天一个linux命令（53）-watch命令/" title="每天一个linux命令（53）: watch命令">每天一个linux命令（53）: watch命令</a></li>
<li><a href="/2017/01/22/linux/每天一个linux命令（54）-at命令/" title="每天一个linux命令（54）: at命令">每天一个linux命令（54）: at命令</a></li>
<li><a href="/2017/01/23/linux/每天一个linux命令（55）-crontab命令/" title="每天一个linux命令（55）: crontab命令">每天一个linux命令（55）: crontab命令</a></li>
<li><a href="/2017/02/20/linux/每天一个linux命令（56）-tailf命令/" title="每天一个linux命令（56）: tailf命令">每天一个linux命令（56）: tailf命令</a></li>
<li><a href="/2017/03/05/linux/每天一个linux命令（57）-sftp命令/" title="每天一个linux命令（57）: sftp命令">每天一个linux命令（57）: sftp命令</a>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始详细的系统的学习linux命令，坚持每天一个命令。&lt;br&gt;此专题下的&lt;code&gt;每天一个linux命令&lt;/code&gt;来源于 yelog.&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（55）: crontab命令</title>
    <link href="http://s.amlove.cn/2017/01/23/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8855%EF%BC%89-crontab%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/23/linux/每天一个linux命令（55）-crontab命令/</id>
    <published>2017-01-23T02:44:50.000Z</published>
    <updated>2017-03-13T04:11:01.651Z</updated>
    
    <content type="html"><![CDATA[<p>　　前一天学习了 at 命令是针对仅运行一次的任务，循环运行的例行性计划任务，linux系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。<br><a id="more"></a></p>
<h3 id="crond简介"><a href="#crond简介" class="headerlink" title="crond简介"></a>crond简介</h3><p>　　crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<p>　　Linux下的任务调度分为两类，系统任务调度和用户任务调度。</p>
<p>　　系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p>
<p>　　/etc/crontab文件包括下面几行：</p>
<pre><code class="bash"># /etc/crontab: system-wide crontab
# Unlike any other crontab you don&#39;t have to run the `crontab&#39;
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# m h dom mon dow user    command
17 *    * * *    root    cd / &amp;&amp; run-parts --report /etc/cron.hourly
25 6    * * *    root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )
47 6    * * 7    root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )
52 6    1 * *    root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )
</code></pre>
<p>　　前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p>
<p>　　用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p>
<h3 id="使用者权限文件"><a href="#使用者权限文件" class="headerlink" title="使用者权限文件"></a>使用者权限文件</h3><p>文件：/etc/cron.deny<br>说明：该文件中所列用户不允许使用crontab命令</p>
<p>文件：/etc/cron.allow<br>说明：该文件中所列用户允许使用crontab命令</p>
<p>文件：/var/spool/cron/<br>说明：所有用户crontab文件存放的目录,以用户名命名</p>
<h3 id="crontab文件的含义"><a href="#crontab文件的含义" class="headerlink" title="crontab文件的含义"></a>crontab文件的含义</h3><p>　　用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br>minute   hour   day   month   week   command<br>其中：<br>　　minute： 表示分钟，可以是从0到59之间的任何整数。<br>　　hour：表示小时，可以是从0到23之间的任何整数。<br>　　day：表示日期，可以是从1到31之间的任何整数。<br>　　month：表示月份，可以是从1到12之间的任何整数。<br>　　week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>　　command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
<p><strong>在以上各个字段中，还可以使用以下特殊字符：</strong><br><code>星号（*）</code>：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br><code>逗号（,）</code>：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br><code>中杠（-）</code>：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br><code>正斜线（/）</code>：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p>
<h3 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h3><p>安装crontab：</p>
<pre><code class="bash">$ yum install crontabs
</code></pre>
<p>服务操作说明：</p>
<pre><code class="bash">$ /sbin/service crond start //启动服务
$ /sbin/service crond stop //关闭服务
$ /sbin/service crond restart //重启服务
$ /sbin/service crond reload //重新载入配置
</code></pre>
<p>查看crontab服务状态：</p>
<pre><code class="bash">$ service crond status
</code></pre>
<p>手动启动crontab服务：</p>
<pre><code class="bash">$ service crond start
</code></pre>
<p>查看crontab服务是否已设置为开机启动，执行命令：</p>
<pre><code class="bash">$ ntsysv
</code></pre>
<p>加入开机自动启动：</p>
<pre><code class="bash">$ chkconfig –level 35 crond on
</code></pre>
<h2 id="contab-命令详解"><a href="#contab-命令详解" class="headerlink" title="contab 命令详解"></a>contab 命令详解</h2><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ crontab [-u user] file
$ crontab [-u user] [ -e | -l | -r ]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-u user</td>
<td style="text-align:left">用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</td>
</tr>
<tr>
<td style="text-align:left">-e</td>
<td style="text-align:left">编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:left">显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件</td>
</tr>
<tr>
<td style="text-align:left">-i</td>
<td style="text-align:left">在删除用户的crontab文件时给确认提示</td>
</tr>
</tbody>
</table>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong><code>例一</code>：创建一个新的crontab文件</strong><br>在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其中加入这样一行：<br>EDITOR=vi; export EDITOR<br>然后保存并退出。不妨创建一个名为<user> cron的文件，其中<user>是用户名，例如， davecron。在该文件中加入如下的内容。</user></user></p>
<pre><code>     # (put your own initials here)echo the date to the console every
     # 15minutes between 6pm and 6am
     0,15,30,45 18-06 * * * /bin/echo &#39;date&#39; &gt; /dev/console
保存并退出。确信前面5个域用空格分隔。
</code></pre><p>在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数：<br>        $ crontab davecron<br>现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。<br>同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。<br><strong><code>例二</code>：列出crontab文件</strong></p>
<pre><code class="bash">$ crontab -l
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份：<br>        $ crontab -l &gt; $HOME/mycron<br>这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p>
</blockquote>
<p><strong><code>例三</code>：编辑crontab文件</strong></p>
<pre><code class="bash">$ crontab -e
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>可以像使用v i编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。<br>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p>
<pre><code>   # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month
    30 3 1,7,14,21,26 * * /bin/find -name &quot;core&#39; -exec rm {} \;
</code></pre><p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。<br>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：<br>       $ crontab -l</p>
<pre><code>   # (crondave installed on Tue May 4 13:07:43 1999)
   # DT:ech the date to the console every 30 minites
  0,15,30,45 18-06 * * * /bin/echo `date` &gt; /dev/tty1
   # DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month
   30 3 1,7,14,21,26 * * /bin/find -name &quot;core&#39; -exec rm {} \;
</code></pre></blockquote>
<p><strong><code>例四</code>：删除crontab文件</strong></p>
<pre><code class="bash">$ crontab -r
</code></pre>
<p><strong><code>例五</code>：恢复丢失的crontab文件</strong><br>如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/<username>，其中<username>是用户名。如果由于权限问题无法完成拷贝，可以用：<br>        $ crontab <filename><br>    其中，<filename>是你在$ H O M E目录中副本的文件名。<br>我建议你在自己的$ H O M E目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。<br>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<ctrl-d>，否则你将丢失crontab文件。</ctrl-d></filename></filename></username></username></p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：每1分钟执行一次command</strong></p>
<pre><code class="bash">* * * * * command
</code></pre>
<p><strong><code>例二</code>：每小时的第3和第15分钟执行</strong></p>
<pre><code class="bash">3,15 * * * * command
</code></pre>
<p><strong><code>例三</code>：在上午8点到11点的第3和第15分钟执行</strong></p>
<pre><code class="bash">3,15 8-11 * * * command
</code></pre>
<p><strong><code>例四</code>：每隔两天的上午8点到11点的第3和第15分钟执行</strong></p>
<pre><code class="bash">3,15 8-11 */2 * * command
</code></pre>
<p><strong><code>例五</code>：每个星期一的上午8点到11点的第3和第15分钟执行</strong></p>
<pre><code class="bash">3,15 8-11 * * 1 command
</code></pre>
<p><strong><code>例六</code>：每晚的21:30重启smb</strong></p>
<pre><code class="bash">30 21 * * * /etc/init.d/smb restart
</code></pre>
<p><strong><code>例七</code>：每月1、10、22日的4 : 45重启smb</strong></p>
<pre><code class="bash">45 4 1,10,22 * * /etc/init.d/smb restart
</code></pre>
<p><strong><code>例八</code>：每周六、周日的1 : 10重启smb</strong></p>
<pre><code class="bash">10 1 * * 6,0 /etc/init.d/smb restart
</code></pre>
<p><strong><code>例九</code>：每天18 : 00至23 : 00之间每隔30分钟重启smb</strong></p>
<pre><code class="bash">0,30 18-23 * * * /etc/init.d/smb restart
</code></pre>
<p><strong><code>例十</code>：每星期六的晚上11 : 00 pm重启smb</strong></p>
<pre><code class="bash">0 23 * * 6 /etc/init.d/smb restart
</code></pre>
<p><strong><code>例十一</code>：每一小时重启smb</strong></p>
<pre><code class="bash">* */1 * * * /etc/init.d/smb restart
</code></pre>
<p><strong><code>例十二</code>：晚上11点到早上7点之间，每隔一小时重启smb</strong></p>
<pre><code class="bash">* 23-7/1 * * * /etc/init.d/smb restart
</code></pre>
<p><strong><code>例十三</code>：每月的4号与每周一到周三的11点重启smb</strong></p>
<pre><code class="bash">0 11 4 * mon-wed /etc/init.d/smb restart
</code></pre>
<p><strong><code>例十四</code>：一月一号的4点重启smb</strong></p>
<pre><code class="bash">0 4 1 jan * /etc/init.d/smb restart
</code></pre>
<p><strong><code>例十五</code>：每小时执行/etc/cron.hourly目录内的脚本</strong></p>
<pre><code class="bash">01   *   *   *   *     root run-parts /etc/cron.hourly
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="注意环境变量问题"><a href="#注意环境变量问题" class="headerlink" title="注意环境变量问题"></a>注意环境变量问题</h4><p>　　有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p>
<p>　　在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。</p>
<p>　　不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：<br>　　1）脚本中涉及文件路径时写全局路径；<br>　　2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</p>
<pre><code class="bash">$ cat start_cbp.sh
#!/bin/sh
source /etc/profile
export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;
</code></pre>
<p>3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p>
<pre><code class="bash">0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh
</code></pre>
<h4 id="注意清理系统用户的邮件日志"><a href="#注意清理系统用户的邮件日志" class="headerlink" title="注意清理系统用户的邮件日志"></a>注意清理系统用户的邮件日志</h4><p>　　每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。<br>　　例如，可以在crontab文件中设置如下形式，忽略日志输出：</p>
<pre><code class="bash">0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1
</code></pre>
<p>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<h4 id="系统级任务调度与用户级任务调度"><a href="#系统级任务调度与用户级任务调度" class="headerlink" title="系统级任务调度与用户级任务调度"></a>系统级任务调度与用户级任务调度</h4><p>　　系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p>
<h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><p>　　新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>
<p>　　当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p>
<p>　　千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p>
<p>　　在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\%Y\%m\%d’。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　前一天学习了 at 命令是针对仅运行一次的任务，循环运行的例行性计划任务，linux系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（54）: at命令</title>
    <link href="http://s.amlove.cn/2017/01/22/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8854%EF%BC%89-at%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/22/linux/每天一个linux命令（54）-at命令/</id>
    <published>2017-01-22T02:23:44.000Z</published>
    <updated>2017-03-13T04:11:01.650Z</updated>
    
    <content type="html"><![CDATA[<p>　　在windows系统中，windows提供了计划任务这一功能，在控制面板 -&gt; 性能与维护 -&gt; 任务计划， 它的功能就是安排自动运行的任务。 通过’添加任务计划’的一步步引导，则可建立一个定时执行的任务。<br><a id="more"></a><br>　　在linux系统中你可能已经发现了为什么系统常常会自动的进行一些任务？这些任务到底是谁在支配他们工作的？在linux系统如果你想要让自己设计的备份程序可以自动在某个时间点开始在系统底下运行，而不需要手动来启动它，又该如何处置呢？ 这些例行的工作可能又分为一次性定时工作与循环定时工作，在系统内又是哪些服务在负责？ 还有，如果你想要每年在老婆的生日前一天就发出一封信件提醒自己不要忘记，linux系统下该怎么做呢？</p>
<p>　　今天我们主要学习一下一次性定时计划任务的at命令的用法！</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ at [参数] [时间]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程（ps -ef | grep atd查看， 开启用/etc/init.d/atd start or restart； 开机即启动则需要运行 chkconfig –level 2345 atd on）。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-m</td>
<td style="text-align:left">当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出</td>
</tr>
<tr>
<td style="text-align:left">-I</td>
<td style="text-align:left">atq的别名</td>
</tr>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">atrm的别名</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">显示任务将被执行的时间</td>
</tr>
<tr>
<td style="text-align:left">-c</td>
<td style="text-align:left">打印任务的内容到标准输出</td>
</tr>
<tr>
<td style="text-align:left">-V</td>
<td style="text-align:left">显示版本信息</td>
</tr>
<tr>
<td style="text-align:left">-q&lt;列队&gt;</td>
<td style="text-align:left">使用指定的列队</td>
</tr>
<tr>
<td style="text-align:left">-f&lt;文件&gt;</td>
<td style="text-align:left">从指定文件读入任务而不是从标准输入读入</td>
</tr>
<tr>
<td style="text-align:left">-t&lt;时间参数&gt;</td>
<td style="text-align:left">以时间参数的形式提交要运行的任务<br>at允许使用一套相当复杂的指定时间的方法。他能够接受在当天的hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用12小时计时制，即在时间后面加上AM（上午）或PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为month day（月 日）或mm/dd/yy（月/日/年）或dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。 上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units ，now就是当前时间，time-units是时间单位，这里能够是minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用today（今天）、tomorrow（明天）来指定完成命令的时间。</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">时间格式，这里可以定义出什么时候要进行 at 这项任务的时间</td>
</tr>
</tbody>
</table>
<p>TIME的格式：<br>HH:MM<br>ex&gt; 04:00<br>在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此任务。</p>
<p>HH:MM YYYY-MM-DD<br>ex&gt; 04:00 2009-03-17<br>强制规定在某年某月的某一天的特殊时刻进行该项任务</p>
<p>HH:MM[am|pm] [Month] [Date]<br>ex&gt; 04pm March 17<br>也是一样，强制在某年某月某日的某时刻进行该项任务</p>
<p>HH:MM[am|pm] + number [minutes|hours|days|weeks]<br>ex&gt; now + 5 minutes<br>ex&gt; 04pm + 3 days<br>就是说，在某个时间点再加几个时间后才进行该项任务。</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：三天后的下午 5 点锺执行 /bin/ls</strong></p>
<pre><code class="bash">$ at 5pm+3 days
at&gt; /bin/ls
at&gt; &lt;EOT&gt; # 按一下Ctrl+d就会出现&lt;EOT&gt;结束符
job 2 at Thu Feb  2 17:00:00 2017
</code></pre>
<p><strong><code>例二</code>：明天17点钟，输出时间到指定文件内</strong></p>
<pre><code class="bash">$ at 17:20 tomorrow
at&gt; date &gt;/root/2013.log   
at&gt; &lt;EOT&gt;
</code></pre>
<p><strong><code>例三</code>：计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务</strong></p>
<pre><code class="bash">$ atq
2    Thu Feb  2 17:00:00 2017 a faker
</code></pre>
<p><strong><code>例四</code>：删除已经设置的任务</strong></p>
<pre><code class="bash"># 2 为atq查出来的最前面的任务id
$ atrm 2
</code></pre>
<p><strong><code>例五</code>：显示已经设置的任务内容</strong></p>
<pre><code class="bash">$ at -c 2
#!/bin/sh
# atrun uid=1000 gid=1000
# mail faker 0
umask 22
此处省略n个字符
/bin/ls
</code></pre>
<h3 id="atd-的启动与-at-运行的方式"><a href="#atd-的启动与-at-运行的方式" class="headerlink" title="atd 的启动与 at 运行的方式"></a>atd 的启动与 at 运行的方式</h3><h4 id="atd-的启动"><a href="#atd-的启动" class="headerlink" title="atd 的启动"></a>atd 的启动</h4><p>　　要使用一次性计划任务时，我们的 Linux 系统上面必须要有负责这个计划任务的服务，那就是 atd 服务。 不过并非所有的 Linux distributions 都默认会把他打开的，所以，某些时刻我们需要手动将atd 服务激活才行。 激活的方法很简单，就是这样：<br><strong>命令：</strong></p>
<pre><code class="bash">$ /etc/init.d/atd start
$ /etc/init.d/atd restart
</code></pre>
<p><strong>配置一下启动时就启动这个服务，免得每次重新启动都得再来一次</strong></p>
<pre><code class="bash">$ chkconfig atd on
</code></pre>
<h4 id="at-的运行方式"><a href="#at-的运行方式" class="headerlink" title="at 的运行方式"></a>at 的运行方式</h4><p>　　既然是计划任务，那么应该会有任务执行的方式，并且将这些任务排进行程表中。那么产生计划任务的方式是怎么进行的? 事实上，我们使用 at 这个命令来产生所要运行的计划任务，并将这个计划任务以文字档的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与运行了。就这么简单。</p>
<p>　　不过，并不是所有的人都可以进行 at 计划任务。为什么? 因为系统安全的原因。很多主机被所谓的攻击破解后，最常发现的就是他们的系统当中多了很多的黑客程序， 这些程序非常可能运用一些计划任务来运行或搜集你的系统运行信息,并定时的发送给黑客。 所以，除非是你认可的帐号，否则先不要让他们使用 at 命令。那怎么达到使用 at 的可控呢?</p>
<p>　　我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个文件来进行 at 的使用限制。加上这两个文件后， at 的工作情况是这样的：</p>
<p>　　先找寻 /etc/at.allow 这个文件，写在这个文件中的使用者才能使用 at ，没有在这个文件中的使用者则不能使用 at (即使没有写在 at.deny 当中);</p>
<p>　　如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个文件，若写在这个 at.deny 的使用者则不能使用 at ，而没有在这个 at.deny 文件中的使用者，就可以使用 at 命令了。</p>
<p>　　如果两个文件都不存在，那么只有 root 可以使用 at 这个命令。</p>
<p>　　透过这个说明，我们知道 /etc/at.allow 是管理较为严格的方式，而 /etc/at.deny 则较为松散 (因为帐号没有在该文件中，就能够运行 at 了)。在一般的 distributions 当中，由于假设系统上的所有用户都是可信任的， 因此系统通常会保留一个空的 /etc/at.deny 文件，意思是允许所有人使用 at 命令的意思 (您可以自行检查一下该文件)。 不过，万一你不希望有某些使用者使用 at 的话，将那个使用者的帐号写入 /etc/at.deny 即可！ 一个帐号写一行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在windows系统中，windows提供了计划任务这一功能，在控制面板 -&amp;gt; 性能与维护 -&amp;gt; 任务计划， 它的功能就是安排自动运行的任务。 通过’添加任务计划’的一步步引导，则可建立一个定时执行的任务。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（53）: watch命令</title>
    <link href="http://s.amlove.cn/2017/01/21/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8853%EF%BC%89-watch%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/21/linux/每天一个linux命令（53）-watch命令/</id>
    <published>2017-01-21T02:12:30.000Z</published>
    <updated>2017-03-13T04:11:01.650Z</updated>
    
    <content type="html"><![CDATA[<p>　　watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。在Linux下，watch是周期性的执行下个程序，并全屏显示执行结果。你可以拿他来监测你想要的一切命令的结果变化，比如 tail 一个 log 文件，ls 监测某个文件的大小变化，看你的想象力了！<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ watch[参数][命令]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-n或–interval</td>
<td style="text-align:left">watch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间</td>
</tr>
<tr>
<td style="text-align:left">-d或–differences</td>
<td style="text-align:left">watch 会高亮显示变化的区域</td>
</tr>
<tr>
<td style="text-align:left">-d=cumulative</td>
<td style="text-align:left">会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来</td>
</tr>
<tr>
<td style="text-align:left">-t 或-no-title</td>
<td style="text-align:left">会关闭watch命令在顶部的时间间隔,命令，当前时间的输出</td>
</tr>
<tr>
<td style="text-align:left">-h, –help</td>
<td style="text-align:left">查看帮助文档</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：每隔一秒高亮显示网络链接数的变化情况</strong></p>
<pre><code class="bash">$ watch -n 1 -d netstat -ant
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>其它操作：<br>切换终端： Ctrl+x<br>退出watch：Ctrl+g (deepin系统没效果，只能使用Ctrl+c退出了)</p>
</blockquote>
<p><strong><code>例二</code>：每隔一秒高亮显示http链接数的变化情况</strong></p>
<pre><code class="bash"># 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加&#39;&#39;将命令区域归整。
$ watch -n 1 -d &#39;pstree|grep http&#39;
</code></pre>
<p><strong><code>例三</code>：实时查看模拟攻击客户机建立起来的连接数</strong></p>
<pre><code class="bash">$ watch &#39;netstat -an | grep:21 | \ grep&lt;模拟攻击客户机的IP&gt;| wc -l&#39;
</code></pre>
<p><strong><code>例四</code>：监测当前目录中 scf’ 的文件的变化</strong></p>
<pre><code class="bash">$ watch -d &#39;ls -l|grep scf&#39;
</code></pre>
<p><strong><code>例五</code>：10秒一次输出系统的平均负载</strong></p>
<pre><code class="bash">$ watch -n 10 &#39;cat /proc/loadavg&#39;
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。在Linux下，watch是周期性的执行下个程序，并全屏显示执行结果。你可以拿他来监测你想要的一切命令的结果变化，比如 tail 一个 log 文件，ls 监测某个文件的大小变化，看你的想象力了！&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（52）: ps命令</title>
    <link href="http://s.amlove.cn/2017/01/20/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8852%EF%BC%89-ps%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/20/linux/每天一个linux命令（52）-ps命令/</id>
    <published>2017-01-20T01:46:16.000Z</published>
    <updated>2017-03-13T04:11:01.649Z</updated>
    
    <content type="html"><![CDATA[<p>　　Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。<br><a id="more"></a><br>　　要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。<br><!--more --><br>　　ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。</p>
<p>　　kill 命令用于杀死进程。<br><strong>linux上进程有5种状态:</strong></p>
<ol>
<li>运行(正在运行或在运行队列中等待)</li>
<li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li>
<li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li>
<li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</li>
<li>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</li>
</ol>
<p><strong>ps工具标识进程的5种状态码:</strong><br>D 不可中断 uninterruptible sleep (usually IO)<br>R 运行 runnable (on run queue)<br>S 中断 sleeping<br>T 停止 traced or stopped<br>Z 僵死 a defunct (”zombie”) process</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ ps [参数]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>用来现实当前进程的状态</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">显示所有进程</td>
</tr>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">显示同一终端下的所有程序</td>
</tr>
<tr>
<td style="text-align:left">-A</td>
<td style="text-align:left">显示所有进程</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">显示进程的真实名称</td>
</tr>
<tr>
<td style="text-align:left">-N</td>
<td style="text-align:left">反向选择</td>
</tr>
<tr>
<td style="text-align:left">-e</td>
<td style="text-align:left">等于“-A”</td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:left">显示环境变量</td>
</tr>
<tr>
<td style="text-align:left">f</td>
<td style="text-align:left">显示程序间的关系</td>
</tr>
<tr>
<td style="text-align:left">-H</td>
<td style="text-align:left">显示树状结构</td>
</tr>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">显示当前终端的进程</td>
</tr>
<tr>
<td style="text-align:left">T</td>
<td style="text-align:left">显示当前终端的所有程序</td>
</tr>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">指定用户的所有进程</td>
</tr>
<tr>
<td style="text-align:left">-au</td>
<td style="text-align:left">显示较详细的资讯</td>
</tr>
<tr>
<td style="text-align:left">-aux</td>
<td style="text-align:left">显示所有包含其他使用者的行程</td>
</tr>
<tr>
<td style="text-align:left">-C&lt;命令&gt;</td>
<td style="text-align:left">列出指定命令的状况</td>
</tr>
<tr>
<td style="text-align:left">–lines&lt;行数&gt;</td>
<td style="text-align:left">每页显示的行数</td>
</tr>
<tr>
<td style="text-align:left">–width&lt;字符数&gt;</td>
<td style="text-align:left">每页显示的字符数</td>
</tr>
<tr>
<td style="text-align:left">–help</td>
<td style="text-align:left">显示帮助信息</td>
</tr>
<tr>
<td style="text-align:left">–version</td>
<td style="text-align:left">显示版本显示</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：显示所有进程信息</strong></p>
<pre><code class="bash">$ ps -A
</code></pre>
<p><strong><code>例二</code>：显示指定用户的进程信息</strong></p>
<pre><code class="bash">$ ps -u faker
</code></pre>
<p><strong><code>例三</code>：显示所有进程信息，连同命令行</strong></p>
<pre><code class="bash">$ ps -ef
</code></pre>
<p><strong><code>例四</code>：ps 与grep 常用组合用法，查找特定进程</strong></p>
<pre><code class="bash">$ ps -ef|grep ssh
</code></pre>
<p><strong><code>例五</code>：将目前属于您自己这次登入的 PID 与相关信息列示出来</strong></p>
<pre><code class="bash">$ ps -l
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>各相关信息的意义：<br>　　F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user<br>　　S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍<br>　　UID 程序被该 UID 所拥有<br>　　PID 就是这个程序的 ID ！<br>　　PPID 则是其上级父程序的ID<br>　　C CPU 使用的资源百分比<br>　　PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍<br>　　NI 这个是 Nice 值，在下一小节我们会持续介绍<br>　　ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“<br>　　SZ 使用掉的内存大小<br>　　WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作<br>　　TTY 登入者的终端机位置<br>　　TIME 使用掉的 CPU 时间。<br>　　CMD 所下达的指令为何<br>　　在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID。</p>
</blockquote>
<p><strong><code>例六</code>：列出目前所有的正在内存当中的程序</strong></p>
<pre><code class="bash">$ ps aux
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>　　USER：该 process 属于那个使用者账号的<br>　　PID ：该 process 的号码<br>　　%CPU：该 process 使用掉的 CPU 资源百分比<br>　　%MEM：该 process 所占用的物理内存百分比<br>　　VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)<br>　　RSS ：该 process 占用的固定的内存量 (Kbytes)<br>　　TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。<br>　　STAT：该程序目前的状态，主要的状态有<br>　　R ：该程序目前正在运作，或者是可被运作<br>　　S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。<br>　　T ：该程序目前正在侦测或者是停止了<br>　　Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态<br>　　START：该 process 被触发启动的时间<br>　　TIME ：该 process 实际使用 CPU 运作的时间<br>　　COMMAND：该程序的实际指令</p>
</blockquote>
<p><strong><code>例七</code>：列出类似程序树的程序显示</strong></p>
<pre><code class="bash">$ ps -axjf
</code></pre>
<p><strong><code>例八</code>：找出与 cron 与 syslog 这两个服务有关的 PID 号码</strong></p>
<pre><code class="bash">$ ps aux | egrep &#39;(cron|syslog)&#39;
</code></pre>
<p><strong><code>其他</code></strong></p>
<pre><code class="bash"># 可以用 | 管道和 more 连接起来分页查看
$ ps -aux |more

# 把所有进程显示出来，并输出到ps001.txt文件
$ ps -aux &gt; ps001.txt

# 输出指定的字段
$ ps -o pid,ppid,pgrp,session,tpgid,comm
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（51）: wc命令</title>
    <link href="http://s.amlove.cn/2017/01/19/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8851%EF%BC%89-wc%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/19/linux/每天一个linux命令（51）-wc命令/</id>
    <published>2017-01-19T01:33:59.000Z</published>
    <updated>2017-03-13T04:11:01.649Z</updated>
    
    <content type="html"><![CDATA[<p>　　Linux系统中的wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ wc [选项]文件...
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-c</td>
<td style="text-align:left">统计字节数</td>
</tr>
<tr>
<td style="text-align:left">-l</td>
<td style="text-align:left">统计行数</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td style="text-align:left">统计字符数。这个标志不能与 -c 标志一起使用</td>
</tr>
<tr>
<td style="text-align:left">-w</td>
<td style="text-align:left">统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串</td>
</tr>
<tr>
<td style="text-align:left">-L</td>
<td style="text-align:left">打印最长行的长度</td>
</tr>
<tr>
<td style="text-align:left">-help</td>
<td style="text-align:left">显示帮助信息</td>
</tr>
<tr>
<td style="text-align:left">–version</td>
<td style="text-align:left">显示版本信息</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：查看文件的字节数、字数、行数</strong></p>
<pre><code class="bash">$ wc 1.txt
 5    19   105   1.txt
 行数 单词数 字节数 文件名
</code></pre>
<p><strong><code>例二</code>：用wc命令怎么做到只打印统计数字不打印文件名</strong></p>
<pre><code class="bash">$ wc -l 1.txt
5 1.txt # 5行

$ cat 1.txt | wc -l
5 # 值输出数字
</code></pre>
<p><strong><code>例三</code>：用来统计当前目录下的文件和文件夹总数</strong></p>
<pre><code class="bash"># 数量中包含当前目录
$ ls -l | wc -l
10 # 7个文件 + 2个文件夹 + 1个当前目录
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Linux系统中的wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（50）: grep命令</title>
    <link href="http://s.amlove.cn/2017/01/18/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8850%EF%BC%89-grep%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/18/linux/每天一个linux命令（50）-grep命令/</id>
    <published>2017-01-18T02:12:46.000Z</published>
    <updated>2017-03-13T04:11:01.648Z</updated>
    
    <content type="html"><![CDATA[<p>　　Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。<br><a id="more"></a><br>　　grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p>
<p>　　grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ grep [option] pattern file
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-a <br>–text</td>
<td style="text-align:left">不要忽略二进制的数据</td>
</tr>
<tr>
<td style="text-align:left">-A&lt;显示行数&gt;  <br>–after-context=&lt;显示行数&gt;</td>
<td style="text-align:left">除了显示符合范本样式的那一列之外，并显示该行之后的内容</td>
</tr>
<tr>
<td style="text-align:left">-b <br>–byte-offset</td>
<td style="text-align:left">在显示符合样式的那一行之前，标示出该行第一个字符的编号</td>
</tr>
<tr>
<td style="text-align:left">-B&lt;显示行数&gt;  <br>–before-context=&lt;显示行数&gt;</td>
<td style="text-align:left">除了显示符合样式的那一行之外，并显示该行之前的内容</td>
</tr>
<tr>
<td style="text-align:left">-c    <br>–count</td>
<td style="text-align:left">计算符合样式的列数</td>
</tr>
<tr>
<td style="text-align:left">-C&lt;显示行数&gt;    <br>–context=&lt;显示行数&gt;或-&lt;显示行数&gt;</td>
<td style="text-align:left">了显示符合样式的那一行之外，并显示该行之前后的内容</td>
</tr>
<tr>
<td style="text-align:left">-d &lt;动作&gt;      <br>–directories=&lt;动作&gt;</td>
<td style="text-align:left">当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作</td>
</tr>
<tr>
<td style="text-align:left">-e&lt;范本样式&gt;  <br>–regexp=&lt;范本样式&gt;</td>
<td style="text-align:left">指定字符串做为查找文件内容的样式</td>
</tr>
<tr>
<td style="text-align:left">-E      <br>–extended-regexp</td>
<td style="text-align:left">将样式为延伸的普通表示法来使用</td>
</tr>
<tr>
<td style="text-align:left">-f&lt;规则文件&gt;  <br>–file=&lt;规则文件&gt;</td>
<td style="text-align:left">指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式</td>
</tr>
<tr>
<td style="text-align:left">-F   <br>–fixed-regexp</td>
<td style="text-align:left">将样式视为固定字符串的列表</td>
</tr>
<tr>
<td style="text-align:left">-G   <br>–basic-regexp</td>
<td style="text-align:left">样式视为普通的表示法来使用</td>
</tr>
<tr>
<td style="text-align:left">-h   <br>–no-filename</td>
<td style="text-align:left">在显示符合样式的那一行之前，不标示该行所属的文件名称</td>
</tr>
<tr>
<td style="text-align:left">-H   <br>–with-filename</td>
<td style="text-align:left">在显示符合样式的那一行之前，表示该行所属的文件名称</td>
</tr>
<tr>
<td style="text-align:left">-i    <br>–ignore-case</td>
<td style="text-align:left">忽略字符大小写的差别</td>
</tr>
<tr>
<td style="text-align:left">-l    <br>–file-with-matches</td>
<td style="text-align:left">列出文件内容符合指定的样式的文件名称</td>
</tr>
<tr>
<td style="text-align:left">-L   <br>–files-without-match</td>
<td style="text-align:left">列出文件内容不符合指定的样式的文件名称</td>
</tr>
<tr>
<td style="text-align:left">-n   <br>–line-number</td>
<td style="text-align:left">在显示符合样式的那一行之前，标示出该行的列数编号</td>
</tr>
<tr>
<td style="text-align:left">-q   <br>–quiet或–silent</td>
<td style="text-align:left">不显示任何信息</td>
</tr>
<tr>
<td style="text-align:left">-r   <br>–recursive</td>
<td style="text-align:left">此参数的效果和指定“-d recurse”参数相同</td>
</tr>
<tr>
<td style="text-align:left">-s   <br>–no-messages</td>
<td style="text-align:left">不显示错误信息</td>
</tr>
<tr>
<td style="text-align:left">-v   <br>–revert-match</td>
<td style="text-align:left">显示不包含匹配文本的所有行</td>
</tr>
<tr>
<td style="text-align:left">-V   <br>–version</td>
<td style="text-align:left">显示版本信息</td>
</tr>
<tr>
<td style="text-align:left">-w   <br>–word-regexp</td>
<td style="text-align:left">只显示全字符合的列</td>
</tr>
<tr>
<td style="text-align:left">-x    <br>–line-regexp</td>
<td style="text-align:left">只显示全列符合的列</td>
</tr>
<tr>
<td style="text-align:left">-y</td>
<td style="text-align:left">此参数的效果和指定“-i”参数相同</td>
</tr>
</tbody>
</table>
<h3 id="规则表达式"><a href="#规则表达式" class="headerlink" title="规则表达式"></a>规则表达式</h3><p><strong>grep的规则表达式</strong><br>　　<code>^</code>  #锚定行的开始 如：<code>&#39;^grep&#39;</code>匹配所有以grep开头的行。<br>　　<code>$</code>  #锚定行的结束 如：<code>&#39;grep$&#39;</code>匹配所有以grep结尾的行。<br>　　<code>.</code>  #匹配一个非换行符的字符 如：<code>&#39;gr.p&#39;</code>匹配gr后接一个任意字符，然后是p。<br>　　<code>*</code>  #匹配零个或多个先前字符 如：<code>&#39;*grep&#39;</code>匹配所有一个或多个空格后紧跟grep的行。<br>　　<code>.*</code>   #一起用代表任意字符。<br>　　<code>[]</code>   #匹配一个指定范围内的字符，如<code>&#39;[Gg]rep&#39;</code>匹配Grep和grep。<br>　　<code>[^]</code>  #匹配一个不在指定范围内的字符，如：<code>&#39;[^A-FH-Z]rep&#39;</code>匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。<br>　　<code>\(..\)</code>  #标记匹配字符，如<code>&#39;\(love\)&#39;</code>，love被标记为1。<br>　　<code>\&lt;</code>      #锚定单词的开始，如:<code>&#39;\&lt;grep&#39;</code>匹配包含以grep开头的单词的行。<br>　　<code>\&gt;</code>      #锚定单词的结束，如<code>&#39;grep\&gt;&#39;</code>匹配包含以grep结尾的单词的行。<br>　　<code>x\{m\}</code>  #重复字符x，m次，如：<code>&#39;0\{5\}&#39;</code>匹配包含5个o的行。<br>　　<code>x\{m,\}</code>  #重复字符x,至少m次，如：<code>&#39;o\{5,\}&#39;</code>匹配至少有5个o的行。<br>　　<code>x\{m,n\}</code>  #重复字符x，至少m次，不多于n次，如：<code>&#39;o\{5,10\}&#39;</code>匹配5–10个o的行。<br>　　<code>\w</code>    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：<code>&#39;G\w*p&#39;</code>匹配以G后跟零个或多个文字或数字字符，然后是p。<br>　　<code>\W</code>   #<code>\w</code>的反置形式，匹配一个或多个非单词字符，如点号句号等。<br>　　<code>\b</code>   #单词锁定符，如: <code>&#39;\bgrep\b&#39;</code>只匹配grep。<br><strong>POSIX字符</strong><br>　　为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。<br>　　[:alnum:]    #文字数字字符<br>　　[:alpha:]    #文字字符<br>　　[:digit:]    #数字字符<br>　　[:graph:]    #非空字符（非空格、控制字符）<br>　　[:lower:]    #小写字符<br>　　[:cntrl:]    #控制字符<br>　　[:print:]    #非空字符（包括空格）<br>　　[:punct:]    #标点符号<br>　　[:space:]    #所有空白字符（新行，空格，制表符）<br>　　[:upper:]    #大写字符<br>　　[:xdigit:]   #十六进制数字（0-9，a-f，A-F）</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：查找指定进程</strong></p>
<pre><code class="bash">$ ps -ef|grep hexo
faker    13401 19030  0 09:51 pts/2    00:00:15 hexo
faker    15465 15449  0 10:34 pts/3    00:00:00 grep hexo
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>第一条记录是查找出的进程；第二条结果是grep进程本身，并非真正要找的进程。</p>
</blockquote>
<p><strong><code>例二</code>：查找指定进程数</strong></p>
<pre><code class="bash">$ ps -ef|grep hexo -c
$ ps -ef|grep -c hexo
2
</code></pre>
<p><strong><code>例三</code>：从2.txt中读取关键词在1.txt中进行搜索</strong></p>
<pre><code class="bash"># -n显示行号
$ cat 1.txt | grep -nf 2.txt
1:If you please draw me a sheep!
2:What!
</code></pre>
<p><strong><code>例四</code>：从文件中查找关键词</strong></p>
<pre><code class="bash">$ grep &#39;jump&#39; 1.txt
I jumped to my feet,completely thunderstruck.
</code></pre>
<p><strong><code>例五</code>：从多个文件中查找关键词</strong></p>
<pre><code class="bash">$ grep &#39;jump&#39; 1.txt 2.txt
1.txt:I jumped to my feet,completely thunderstruck.
2.txt:I jump
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>多文件时，输出查询到的信息内容行时，会把文件的命名在行最前面输出并且加上”:”作为标示符</p>
</blockquote>
<p><strong><code>例六</code>：grep不显示本身进程</strong></p>
<pre><code class="bash">$ ps aux|grep \[s]sh
$ ps aux | grep ssh | grep -v &quot;grep&quot;
</code></pre>
<p><strong><code>例七</code>：找出以u开头的行内容</strong></p>
<pre><code class="bash">$ cat 1.txt |grep ^u
If you please draw me a sheep!
I jumped to my feet,completely thunderstruck.
</code></pre>
<p><strong><code>例八</code>：输出非u开头的行内容</strong></p>
<pre><code class="bash">$ cat 1.txt | grep ^[^I]
What!
Draw me a sheep!
</code></pre>
<p><strong><code>例九</code>：输出以!结尾的行内容</strong></p>
<pre><code class="bash">$ cat 1.txt |grep \!$
If you please draw me a sheep!
What!
Draw me a sheep!
</code></pre>
<p><strong><code>例十</code>：显示包含sh或者at字符的内容行</strong></p>
<pre><code class="bash">$ cat 1.txt |grep -E &quot;sh|at&quot;
If you please draw me a sheep!
What!
Draw me a sheep!
</code></pre>
<p><strong><code>例十一</code>：显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行</strong></p>
<pre><code class="bash">$ grep &#39;[a-z]\{7\}&#39; *.txt
1.txt:I jumped to my feet,completely thunderstruck.
3.txt:kdfkksjdf112123
4.txt:kisdfsf
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（49）: cal命令</title>
    <link href="http://s.amlove.cn/2017/01/17/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8849%EF%BC%89-cal%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/17/linux/每天一个linux命令（49）-cal命令/</id>
    <published>2017-01-17T01:38:32.000Z</published>
    <updated>2017-03-13T04:11:01.647Z</updated>
    
    <content type="html"><![CDATA[<p>　　cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。“阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又名“西历”。<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ cal [参数][月份][年份]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-1</td>
<td style="text-align:left">显示一个月的月历</td>
</tr>
<tr>
<td style="text-align:left">-3</td>
<td style="text-align:left">显示系统前一个月，当前月，下一个月的月历</td>
</tr>
<tr>
<td style="text-align:left">-s</td>
<td style="text-align:left">显示星期天为一个星期的第一天，默认的格式</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td style="text-align:left">显示星期一为一个星期的第一天</td>
</tr>
<tr>
<td style="text-align:left">-j</td>
<td style="text-align:left">显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数）</td>
</tr>
<tr>
<td style="text-align:left">-y</td>
<td style="text-align:left">显示当前年份的日历</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：显示当前月份日历</strong></p>
<pre><code class="bash">$ cal
</code></pre>
<p><img src="/file2017/01/cal.png" alt="日历"><br><strong><code>例二</code>：显示指定月份的日历</strong></p>
<pre><code class="bash">$ cal 6 2016
</code></pre>
<p><img src="/file2017/01/cal-2.png" alt="2016年6月"><br><strong><code>例三</code>：显示2016年的日历</strong></p>
<pre><code class="bash">$ cal -y 2016
$ cal 2016
</code></pre>
<p><img src="/file2017/01/cal-y-2016.png" alt="2016年日历"><br><strong><code>例四</code>：显示自1月1日的天数</strong></p>
<pre><code class="bash">$ cal -j
</code></pre>
<p><img src="/file2017/01/cal-j.png" alt="本年的第几天"></p>
<p><strong><code>例五</code>：星期一显示在第一列</strong></p>
<pre><code class="bash">$ cal -m
</code></pre>
<p><img src="/file2017/01/cal-5.png" alt="本机deepin不支持这个参数，登陆到服务器接了一张图=="></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。“阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又名“西历”。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（48）: date命令</title>
    <link href="http://s.amlove.cn/2017/01/16/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8848%EF%BC%89-date%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/16/linux/每天一个linux命令（48）-date命令/</id>
    <published>2017-01-16T06:39:27.000Z</published>
    <updated>2017-03-13T04:11:01.646Z</updated>
    
    <content type="html"><![CDATA[<p>　　在linux环境中，不管是编程还是其他维护，时间是必不可少的，也经常会用到时间的运算，熟练运用date命令来表示自己想要表示的时间，肯定可以给自己的工作带来诸多方便。<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ date [参数]... [+格式]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　date 可以用来显示或设定系统的日期与时间。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p><strong>命令参数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%H</td>
<td style="text-align:left">小时(以00-23来表示)</td>
</tr>
<tr>
<td style="text-align:left">%I</td>
<td style="text-align:left">小时(以01-12来表示)</td>
</tr>
<tr>
<td style="text-align:left">%K</td>
<td style="text-align:left">小时(以0-23来表示)</td>
</tr>
<tr>
<td style="text-align:left">%l</td>
<td style="text-align:left">小时(以0-12来表示)</td>
</tr>
<tr>
<td style="text-align:left">%M</td>
<td style="text-align:left">分钟(以00-59来表示)</td>
</tr>
<tr>
<td style="text-align:left">%P</td>
<td style="text-align:left">AM或PM</td>
</tr>
<tr>
<td style="text-align:left">%r</td>
<td style="text-align:left">时间(含时分秒，小时以12小时AM/PM来表示)</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">总秒数。起算时间为1970-01-01 00:00:00 UTC</td>
</tr>
<tr>
<td style="text-align:left">%S</td>
<td style="text-align:left">秒(以本地的惯用法来表示)</td>
</tr>
<tr>
<td style="text-align:left">%T</td>
<td style="text-align:left">时间(含时分秒，小时以24小时制来表示)</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:left">时间(以本地的惯用法来表示)</td>
</tr>
<tr>
<td style="text-align:left">%Z</td>
<td style="text-align:left">市区</td>
</tr>
<tr>
<td style="text-align:left">%a</td>
<td style="text-align:left">星期的缩写</td>
</tr>
<tr>
<td style="text-align:left">%A</td>
<td style="text-align:left">星期的完整名称</td>
</tr>
<tr>
<td style="text-align:left">%b</td>
<td style="text-align:left">月份英文名的缩写</td>
</tr>
<tr>
<td style="text-align:left">%B</td>
<td style="text-align:left">月份的完整英文名称</td>
</tr>
<tr>
<td style="text-align:left">%c</td>
<td style="text-align:left">日期与时间。只输入date指令也会显示同样的结果</td>
</tr>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">日期(以01-31来表示)</td>
</tr>
<tr>
<td style="text-align:left">%D</td>
<td style="text-align:left">日期(含年月日)</td>
</tr>
<tr>
<td style="text-align:left">%j</td>
<td style="text-align:left">该年中的第几天</td>
</tr>
<tr>
<td style="text-align:left">%m</td>
<td style="text-align:left">月份(以01-12来表示)</td>
</tr>
<tr>
<td style="text-align:left">%U</td>
<td style="text-align:left">该年中的周数</td>
</tr>
<tr>
<td style="text-align:left">%w</td>
<td style="text-align:left">该周的天数，0代表周日，1代表周一，异词类推</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:left">日期(以本地的惯用法来表示)</td>
</tr>
<tr>
<td style="text-align:left">%y</td>
<td style="text-align:left">年份(以00-99来表示)</td>
</tr>
<tr>
<td style="text-align:left">%Y</td>
<td style="text-align:left">年份(以四位数来表示)</td>
</tr>
<tr>
<td style="text-align:left">%n</td>
<td style="text-align:left">在显示时，插入新的一行</td>
</tr>
<tr>
<td style="text-align:left">%t</td>
<td style="text-align:left">在显示时，插入tab</td>
</tr>
<tr>
<td style="text-align:left">MM</td>
<td style="text-align:left">月份(必要)</td>
</tr>
<tr>
<td style="text-align:left">DD</td>
<td style="text-align:left">日期(必要)</td>
</tr>
<tr>
<td style="text-align:left">hh</td>
<td style="text-align:left">小时(必要)</td>
</tr>
<tr>
<td style="text-align:left">mm</td>
<td style="text-align:left">分钟(必要)</td>
</tr>
<tr>
<td style="text-align:left">ss</td>
<td style="text-align:left">秒(选择性)</td>
</tr>
</tbody>
</table>
<p><strong>选择参数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-d&lt;字符串&gt;</td>
<td style="text-align:left">显示字符串所指的日期与时间。字符串前后必须加上双引号</td>
</tr>
<tr>
<td style="text-align:left">-s&lt;字符串&gt;</td>
<td style="text-align:left">根据字符串来设置日期与时间。字符串前后必须加上双引号</td>
</tr>
<tr>
<td style="text-align:left">-u</td>
<td style="text-align:left">显示GMT</td>
</tr>
<tr>
<td style="text-align:left">–help</td>
<td style="text-align:left">在线帮助</td>
</tr>
<tr>
<td style="text-align:left">–version</td>
<td style="text-align:left">显示版本信息</td>
</tr>
</tbody>
</table>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p><strong>1.在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下: % :  打印出 %</strong><br>%n : 下一行<br>%t : 跳格<br>%H : 小时(00..23)<br>%I : 小时(01..12)<br>%k : 小时(0..23)<br>%l : 小时(1..12)<br>%M : 分钟(00..59)<br>%p : 显示本地 AM 或 PM<br>%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)<br>%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数<br>%S : 秒(00..61)<br>%T : 直接显示时间 (24 小时制)<br>%X : 相当于 %H:%M:%S<br>%Z : 显示时区 %a : 星期几 (Sun..Sat)<br>%A : 星期几 (Sunday..Saturday)<br>%b : 月份 (Jan..Dec)<br>%B : 月份 (January..December)<br>%c : 直接显示日期与时间<br>%d : 日 (01..31)<br>%D : 直接显示日期 (mm/dd/yy)<br>%h : 同 %b<br>%j : 一年中的第几天 (001..366)<br>%m : 月份 (01..12)<br>%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)<br>%w : 一周中的第几天 (0..6)<br>%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)<br>%x : 直接显示日期 (mm/dd/yy)<br>%y : 年份的最后两位数字 (00.99)<br>%Y : 完整年份 (0000..9999)<br><strong>2.在设定时间方面</strong><br>date -s //设置当前时间，只有root权限才能设置，其他只能查看。<br>date -s 20080523 //设置成20080523，这样会把具体时间设置成空00:00:00<br>date -s 01:01:01 //设置具体时间，不会对日期做更改<br>date -s “01:01:01 2008-05-23″ //这样可以设置全部时间<br>date -s “01:01:01 20080523″ //这样可以设置全部时间<br>date -s “2008-05-23 01:01:01″ //这样可以设置全部时间<br>date -s “20080523 01:01:01″ //这样可以设置全部时间<br><strong>3.加减</strong><br>date +%Y%m%d         //显示前天年月日<br>date +%Y%m%d –date=”+1 day”  //显示前一天的日期<br>date +%Y%m%d –date=”-1 day”  //显示后一天的日期<br>date +%Y%m%d –date=”-1 month”  //显示上一月的日期<br>date +%Y%m%d –date=”+1 month”  //显示下一月的日期<br>date +%Y%m%d –date=”-1 year”  //显示前一年的日期<br>date +%Y%m%d –date=”+1 year”  //显示下一年的日期</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：显示当前时间</strong></p>
<pre><code class="bash">$ date
2017年 01月 28日 星期六 14:51:10 CST

$ date &#39;+%c&#39;
2017年01月28日 星期六 14时51分35秒

$ date &#39;+%D&#39;
01/28/17

$ date &#39;+%x&#39;
2017年01月28日

$ date &#39;+%T&#39;
14:52:02

$ date &#39;+%X&#39;
14时52分06秒
</code></pre>
<p><strong><code>例二</code>：显示日期和设定时间</strong></p>
<pre><code class="bash">$ date --date 08:42:00
</code></pre>
<p><strong><code>例三</code>：date -d参数使用</strong></p>
<pre><code class="bash">$ date -d &quot;nov 22&quot;
2012年 11月 22日 星期四 00:00:00 CST

$ date -d &#39;2 weeks&#39;
2012年 12月 22日 星期六 08:50:21 CST

$ date -d &#39;next monday&#39;
2012年 12月 10日 星期一 00:00:00 CST

$ date -d next-day +%Y%m%d
20121209

$ date -d tomorrow +%Y%m%d
20121209

$ date -d last-day +%Y%m%d
20121207

$ date -d yesterday +%Y%m%d
20121207

$ date -d last-month +%Y%m
201211

$ date -d next-month +%Y%m
201301

$ date -d &#39;30 days ago&#39;
2012年 11月 08日 星期四 08:51:37 CST

$ date -d &#39;-100 days&#39;
2012年 08月 30日 星期四 08:52:03 CST

$ date -d &#39;dec 14 -2 weeks&#39;
2012年 11月 30日 星期五 00:00:00 CST

$ date -d &#39;50 days&#39;
2013年 01月 27日 星期日 08:52:27 CST
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>　　date 命令的另一个扩展是 -d 选项，该选项非常有用。使用这个功能强大的选项，通过将日期作为引号括起来的参数提供，您可以快速地查明一个特定的日期。-d 选项还可以告诉您，相对于当前日期若干天的究竟是哪一天，从现在开始的若干天或若干星期以后，或者以前（过去）。通过将这个相对偏移使用引号括起来，作为 -d 选项的参数，就可以完成这项任务。<br>　　具体说明如下：<br>　　　　date -d “nov 22”  今年的 11 月 22 日是星期三<br>　　　　date -d ‘2 weeks’ 2周后的日期<br>　　　　date -d ‘next monday’ (下周一的日期)<br>　　　　date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d<br>　　　　date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d<br>　　　　date -d last-month +%Y%m(上个月是几月)<br>　　　　date -d next-month +%Y%m(下个月是几月)<br>　　使用 ago 指令，您可以得到过去的日期：<br>　　　　date -d ‘30 days ago’ （30天前的日期）<br>　　使用负数以得到相反的日期：<br>　　　　date -d ‘dec 14 -2 weeks’ （相对:dec 14这个日期的两周前的日期）<br>　　　　date -d ‘-100 days’ (100天以前的日期)<br>　　　　date -d ‘50 days’(50天后的日期)</p>
</blockquote>
<p><strong><code>例四</code>：显示月份和日数</strong></p>
<pre><code class="bash">$ date  &#39;+%B %d&#39;
一月 28
</code></pre>
<p><strong><code>例五</code>：显示时间后跳行，再显示目前日期</strong></p>
<pre><code class="bash">$ date &#39;+%T%n%D&#39;
14:58:23
01/28/17
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在linux环境中，不管是编程还是其他维护，时间是必不可少的，也经常会用到时间的运算，熟练运用date命令来表示自己想要表示的时间，肯定可以给自己的工作带来诸多方便。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（47）: diff命令</title>
    <link href="http://s.amlove.cn/2017/01/15/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8847%EF%BC%89-diff%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/15/linux/每天一个linux命令（47）-diff命令/</id>
    <published>2017-01-15T06:08:08.000Z</published>
    <updated>2017-03-13T04:11:01.646Z</updated>
    
    <content type="html"><![CDATA[<p>　　diff 命令是 linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件以找到改动的地方。diff在命令行中打印每一个行的改动。最新版本的diff还支持二进制文件。diff程序的输出被称为补丁 (patch)，因为Linux系统中还有一个patch程序，可以根据diff的输出将a.c的文件内容更新为b.c。diff是svn、cvs、git等版本控制工具不可或缺的一部分。<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ diff [参数] [文件1或目录1] [文件2或目录2]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">指定要显示多少行的文本。此参数必须与-c或-u参数一并使用</td>
</tr>
<tr>
<td style="text-align:left">-a或–text</td>
<td style="text-align:left">diff预设只会逐行比较文本文件</td>
</tr>
<tr>
<td style="text-align:left">-b或–ignore-space-change</td>
<td style="text-align:left">不检查空格字符的不同</td>
</tr>
<tr>
<td style="text-align:left">-B或–ignore-blank-lines</td>
<td style="text-align:left">不检查空白行</td>
</tr>
<tr>
<td style="text-align:left">-c</td>
<td style="text-align:left">显示全部内文，并标出不同之处</td>
</tr>
<tr>
<td style="text-align:left">-C或–context</td>
<td style="text-align:left">与执行”-c”指令相同</td>
</tr>
<tr>
<td style="text-align:left">-d或–minimal</td>
<td style="text-align:left">使用不同的演算法，以较小的单位来做比较</td>
</tr>
<tr>
<td style="text-align:left">-D或ifdef</td>
<td style="text-align:left">此参数的输出格式可用于前置处理器巨集</td>
</tr>
<tr>
<td style="text-align:left">-e或–ed</td>
<td style="text-align:left">此参数的输出格式可用于ed的script文件</td>
</tr>
<tr>
<td style="text-align:left">-f或-forward-ed</td>
<td style="text-align:left">输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处</td>
</tr>
<tr>
<td style="text-align:left">-H或–speed-large-files</td>
<td style="text-align:left">比较大文件时，可加快速度</td>
</tr>
<tr>
<td style="text-align:left">-l或–ignore-matching-lines</td>
<td style="text-align:left">若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异</td>
</tr>
<tr>
<td style="text-align:left">-i或–ignore-case</td>
<td style="text-align:left">不检查大小写的不同</td>
</tr>
<tr>
<td style="text-align:left">-l或–paginate</td>
<td style="text-align:left">将结果交由pr程序来分页</td>
</tr>
<tr>
<td style="text-align:left">-n或–rcs</td>
<td style="text-align:left">将比较结果以RCS的格式来显示</td>
</tr>
<tr>
<td style="text-align:left">-N或–new-file</td>
<td style="text-align:left">在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较</td>
</tr>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">若比较的文件为C语言的程序码文件时，显示差异所在的函数名称</td>
</tr>
<tr>
<td style="text-align:left">-P或–unidirectional-new-file</td>
<td style="text-align:left">与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较</td>
</tr>
<tr>
<td style="text-align:left">-q或–brief</td>
<td style="text-align:left">仅显示有无差异，不显示详细的信息</td>
</tr>
<tr>
<td style="text-align:left">-r或–recursive</td>
<td style="text-align:left">比较子目录中的文件</td>
</tr>
<tr>
<td style="text-align:left">-s或–report-identical-files</td>
<td style="text-align:left">若没有发现任何差异，仍然显示信息</td>
</tr>
<tr>
<td style="text-align:left">-S或–starting-file</td>
<td style="text-align:left">在比较目录时，从指定的文件开始比较</td>
</tr>
<tr>
<td style="text-align:left">-t或–expand-tabs</td>
<td style="text-align:left">在输出时，将tab字符展开</td>
</tr>
<tr>
<td style="text-align:left">-T或–initial-tab</td>
<td style="text-align:left">在每行前面加上tab字符以便对齐</td>
</tr>
<tr>
<td style="text-align:left">-u,-U或–unified=</td>
<td style="text-align:left">以合并的方式来显示文件内容的不同</td>
</tr>
<tr>
<td style="text-align:left">-v或–version</td>
<td style="text-align:left">显示版本信息</td>
</tr>
<tr>
<td style="text-align:left">-w或–ignore-all-space</td>
<td style="text-align:left">忽略全部的空格字符</td>
</tr>
<tr>
<td style="text-align:left">-W或–width</td>
<td style="text-align:left">在使用-y参数时，指定栏宽</td>
</tr>
<tr>
<td style="text-align:left">-x或–exclude</td>
<td style="text-align:left">不比较选项中所指定的文件或目录</td>
</tr>
<tr>
<td style="text-align:left">-X或–exclude-from</td>
<td style="text-align:left">您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件</td>
</tr>
<tr>
<td style="text-align:left">-y或–side-by-side</td>
<td style="text-align:left">以并列的方式显示文件的异同之处</td>
</tr>
<tr>
<td style="text-align:left">–left-column</td>
<td style="text-align:left">在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容</td>
</tr>
<tr>
<td style="text-align:left">–suppress-common-lines</td>
<td style="text-align:left">在使用-y参数时，仅显示不同之处</td>
</tr>
<tr>
<td style="text-align:left">–help</td>
<td style="text-align:left">显示帮助</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：比较两个文件</strong></p>
<pre><code class="bash">$ diff 1.txt 2.txt
1c1
&lt; ii
---
&gt; iii
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>　　上面的“1c1”表示第一个文件和第二个文件的第1行内容有所不同；<br>　　diff 的normal 显示格式有三种提示:<br>　　　　a - add<br>　　　　c - change<br>　　　　d - delete</p>
</blockquote>
<p><strong><code>例二</code>：并排格式输出</strong></p>
<pre><code class="bash">$ diff 1.txt 2.txt -y -W 50
ii              |    iii
iii                  iii
iiii                iiii
iiiii                iiiii
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>　　“|”表示前后2个文件内容有不同<br>　　“&lt;”表示后面文件比前面文件少了1行内容<br>　　“&gt;”表示后面文件比前面文件多了1行内容</p>
</blockquote>
<p><strong><code>例三</code>：上下文输出格式</strong></p>
<pre><code class="bash">$ diff 1.txt 2.txt  -c
*** 1.txt    2017-01-28 14:24:13.744538252 +0800
--- 2.txt    2017-01-28 14:24:59.096124066 +0800
***************
*** 1,4 ****
! ii
  iii
  iiii
  iiiii
--- 1,4 ----
! iii
  iii
  iiii
  iiiii
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>　　这种方式在开头两行作了比较文件的说明，这里有三中特殊字符：<br>　　“＋” 比较的文件的后者比前着多一行<br>　　“－” 比较的文件的后者比前着少一行<br>　　“！” 比较的文件两者有差别的行</p>
</blockquote>
<p><strong><code>例四</code>：统一格式输出</strong></p>
<pre><code class="bash">$ diff 1.txt 2.txt  -u
--- 1.txt    2017-01-28 14:24:13.744538252 +0800
+++ 2.txt    2017-01-28 14:24:59.096124066 +0800
@@ -1,4 +1,4 @@
-ii
+iii
 iii
 iiii
 iiiii
</code></pre>
<p><strong><code>例五</code>：比较文件夹不同</strong></p>
<pre><code class="bash">$ diff test3 test6
</code></pre>
<p><strong><code>例六</code>：比较两个文件不同，并生产补丁</strong></p>
<pre><code class="bash">$ diff -ruN 1.txt 2.txt &gt;patch.log
</code></pre>
<p><strong><code>例七</code>：打补丁</strong></p>
<pre><code class="bash">$ 1.txt patch
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　diff 命令是 linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件以找到改动的地方。diff在命令行中打印每一个行的改动。最新版本的diff还支持二进制文件。diff程序的输出被称为补丁 (patch)，因为Linux系统中还有一个patch程序，可以根据diff的输出将a.c的文件内容更新为b.c。diff是svn、cvs、git等版本控制工具不可或缺的一部分。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（46）: ln命令</title>
    <link href="http://s.amlove.cn/2017/01/14/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8846%EF%BC%89-ln%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/14/linux/每天一个linux命令（46）-ln命令/</id>
    <published>2017-01-14T03:00:33.000Z</published>
    <updated>2017-03-13T04:11:01.645Z</updated>
    
    <content type="html"><![CDATA[<p>　　ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ ln [参数][源文件或目录][目标文件或目录]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。<br><strong>软连接</strong><br>　　1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>　　2.软链接可以 跨文件系统 ，硬链接不可以<br>　　3.软链接可以对一个不存在的文件名进行链接<br>　　4.软链接可以对目录进行链接<br><strong>硬链接</strong><br>　　1.硬链接，以文件副本的形式存在。但不占用实际空间。<br>　　2.不允许给目录创建硬链接<br>　　3.硬链接只有在同一个文件系统中才能创建<br><strong>两点注意</strong><br>　　第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；<br>　　第二，ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。<br>　　ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p><strong>必要参数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-b</td>
<td style="text-align:left">删除，覆盖以前建立的链接</td>
</tr>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">允许超级用户制作目录的硬链接</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">强制执行</td>
</tr>
<tr>
<td style="text-align:left">-i</td>
<td style="text-align:left">交互模式，文件存在则提示用户是否覆盖</td>
</tr>
<tr>
<td style="text-align:left">-n</td>
<td style="text-align:left">把符号链接视为一般目录</td>
</tr>
<tr>
<td style="text-align:left">-s</td>
<td style="text-align:left">软链接(符号链接)</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">显示详细的处理过程</td>
</tr>
</tbody>
</table>
<p><strong>选择参数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-S</td>
<td style="text-align:left">“-S&lt;字尾备份字符串&gt; ”或 “–suffix=&lt;字尾备份字符串&gt;”</td>
</tr>
<tr>
<td style="text-align:left">-V</td>
<td style="text-align:left">“-V&lt;备份方式&gt;”或“–version-control=&lt;备份方式&gt;”</td>
</tr>
<tr>
<td style="text-align:left">–help</td>
<td style="text-align:left">显示帮助信息</td>
</tr>
<tr>
<td style="text-align:left">–version</td>
<td style="text-align:left">显示版本信息</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：给文件创建软链接</strong></p>
<pre><code class="bash"># 为2.txt文件创建软链接2，如果2.txt丢失，2将失效
$ ln -s 2.txt 2
</code></pre>
<p><strong><code>例二</code>：给文件创建硬链接</strong></p>
<pre><code class="bash"># 为1.txt创建硬链接1，1.txt与1的各项属性相同,删除1.txt，1仍能使用
$ ln 1.txt 1
</code></pre>
<p><strong><code>例三</code>：接上面两实例，链接完毕后，删除和重建链接原文件</strong></p>
<pre><code class="bash">$ ll
-rw-r--r-- 2 faker faker   10 1月  22 11:28 1
-rw-r--r-- 2 faker faker   10 1月  22 11:28 1.txt
lrwxrwxrwx 1 faker faker    5 1月  28 11:15 2 -&gt; 2.txt
-rwxrwxrwx 1 faker faker   14 1月  18 10:06 2.txt

$ rm 1.txt 2.txt
-rw-r--r-- 1 faker faker   10 1月  22 11:28 1
lrwxrwxrwx 1 faker faker    5 1月  28 11:15 2 -&gt; 2.txt

$ cat 1
sdfiskdlf

$ cat 2
cat: 2: 没有那个文件或目录
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>　　1.源文件被删除后，并没有影响硬链接文件；软链接文件在centos系统下不断的闪烁，提示源文件已经不存在<br>　　2.重建源文件后，软链接不在闪烁提示，说明已经链接成功，找到了链接文件系统；重建后，硬链接文件并没有受到源文件影响，硬链接文件的内容还是保留了删除前源文件的内容，说明硬链接已经失效</p>
</blockquote>
<p><strong><code>例三</code>：将文件链接为另一个目录中的相同名字</strong></p>
<pre><code class="bash"># 在ig文件夹中创建一个1.txt的链接
$ ln 1.txt ig/
$ ll ig
-rw-r--r-- 2 faker faker   10 1月  28 13:40 1.txt
</code></pre>
<p><strong><code>例五</code>：给目录创建软连接</strong></p>
<pre><code class="bash">$ ln -s ig gi
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>　　1.目录只能创建软链接<br>　　<del>2.目录创建链接必须用绝对路径，相对路径创建会不成功，会提示：符号连接的层数过多 这样的错误</del>（测试并不会出现这样的问题）<br>　　3.在链接目标目录中修改文件都会在源文件目录中同步变化</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（45）: scp命令</title>
    <link href="http://s.amlove.cn/2017/01/13/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8845%EF%BC%89-scp%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/13/linux/每天一个linux命令（45）-scp命令/</id>
    <published>2017-01-13T02:53:48.000Z</published>
    <updated>2017-03-13T04:11:01.645Z</updated>
    
    <content type="html"><![CDATA[<p>　　scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ scp [参数] [原路径] [目标路径]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-1</td>
<td style="text-align:left">强制scp命令使用协议ssh1</td>
</tr>
<tr>
<td style="text-align:left">-2</td>
<td style="text-align:left">强制scp命令使用协议ssh2</td>
</tr>
<tr>
<td style="text-align:left">-4</td>
<td style="text-align:left">强制scp命令只使用IPv4寻址</td>
</tr>
<tr>
<td style="text-align:left">-6</td>
<td style="text-align:left">强制scp命令只使用IPv6寻址</td>
</tr>
<tr>
<td style="text-align:left">-B</td>
<td style="text-align:left">使用批处理模式（传输过程中不询问传输口令或短语）</td>
</tr>
<tr>
<td style="text-align:left">-C</td>
<td style="text-align:left">允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</td>
</tr>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">保留原文件的修改时间，访问时间和访问权限</td>
</tr>
<tr>
<td style="text-align:left">-q</td>
<td style="text-align:left">不显示传输进度条</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">递归复制整个目录</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题</td>
</tr>
<tr>
<td style="text-align:left">-c cipher</td>
<td style="text-align:left">以cipher将数据传输进行加密，这个选项将直接传递给ssh</td>
</tr>
<tr>
<td style="text-align:left">-F ssh_config</td>
<td style="text-align:left">指定一个替代的ssh配置文件，此参数直接传递给ssh</td>
</tr>
<tr>
<td style="text-align:left">-i identity_file</td>
<td style="text-align:left">从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh</td>
</tr>
<tr>
<td style="text-align:left">-l limit</td>
<td style="text-align:left">限定用户所能使用的带宽，以Kbit/s为单位</td>
</tr>
<tr>
<td style="text-align:left">-o ssh_option</td>
<td style="text-align:left">如果习惯于使用ssh_config(5)中的参数传递方式</td>
</tr>
<tr>
<td style="text-align:left">-P port</td>
<td style="text-align:left">注意是大写的P, port是指定数据传输用到的端口号</td>
</tr>
<tr>
<td style="text-align:left">-S program</td>
<td style="text-align:left">指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong>从本地服务器复制到远程服务器：</strong></p>
<pre><code class="bash"># 指定了用户名，命令执行后需输入密码
$ scp -r img/* root@server:/var/project/img/

# 没有指定用户名，命令执行后需要输入用户名密码
$ scp -r img/* server:/var/project/img/
</code></pre>
<p><strong>从远程服务器复制到本地当前目录：</strong></p>
<pre><code class="bash">$ scp -r server:/var/project/img/* .
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（44）: rcp命令</title>
    <link href="http://s.amlove.cn/2017/01/12/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8844%EF%BC%89-rcp%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/12/linux/每天一个linux命令（44）-rcp命令/</id>
    <published>2017-01-12T02:36:06.000Z</published>
    <updated>2017-03-13T04:11:01.644Z</updated>
    
    <content type="html"><![CDATA[<p>　　rcp代表“remote file copy”（远程文件拷贝）。该命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。<br><a id="more"></a></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ rcp [参数] [源文件] [目标文件]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　rcp命令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">递归地把源目录中的所有内容拷贝到目的目录中。要使用这个选项，目的必须是一个目录</td>
</tr>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">试图保留源文件的修改时间和模式，忽略umask</td>
</tr>
<tr>
<td style="text-align:left">-k</td>
<td style="text-align:left">请求rcp获得在指定区域内的远程主机的Kerberos 许可，而不是获得由krb_relmofhost⑶确定的远程主机区域内的远程主机的Kerberos许可。</td>
</tr>
<tr>
<td style="text-align:left">-x</td>
<td style="text-align:left">为传送的所有数据打开DES加密。这会影响响应时间和CPU利用率，但是可以提高安全性。如果在文件名中指定的路径不是完整的路径名，那么这个路径被解释为相对远程机上同名用户的主目录。如果没有给出远程用户名，就使用当前用户名。如果远程机上的路径包含特殊shell字符，需要用反斜线（\）、双引号（”）或单引号（’）括起来，使所有的shell元字符都能被远程地解释。需要说明的是，rcp不提示输入口令，它通过rsh命令来执行拷贝。</td>
</tr>
<tr>
<td style="text-align:left">directory</td>
<td style="text-align:left">每个文件或目录参数既可以是远程文件名也可以是本地文件名。远程文件名具有如下形式：rname@rhost：path，其中rname是远程用户名，rhost是远程计算机名，path是这个文件的路径。</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong>使用rcp，需要具备的条件</strong><br>　　如果系统中有 /etc/hosts 文件，系统管理员应确保该文件包含要与之进行通信的远程主机的项。<br>　　/etc/hosts 文件中有一行文字，其中包含每个远程系统的以下信息：<br>　　　　<code>internet_address   official_name   alias</code><br>　　例如：<br>　　　　<code>9.186.10.***  webserver1.com.58.webserver</code><br>.rhosts 文件<br>　　.rhosts 文件位于远程系统的主目录下，其中包含本地系统的名称和本地登录名。<br>　　例如，远程系统的 .rhosts 文件中的项可能是：<br>　　　　<code>webserver1 root</code><br>　　其中，webserver1 是本地系统的名称，root 是本地登录名。这样，webserver1 上的 root 即可在包含.rhosts 文件的远程系统中来回复制文件。<br><strong>配置过程:</strong><br>只对root用户生效</p>
<ol>
<li><p>在双方root用户根目录下建立.rhosts文件,并将双方的hostname加进去.在此之前应在双方的 /etc/hosts文件中加入对方的IP和hostname</p>
</li>
<li><p>把rsh服务启动起来,redhat默认是不启动的。<br>方法：用执行ntsysv命令,在rsh选项前用空格键选中,确定退出。然后执行：<br>service xinetd restart即可。</p>
</li>
</ol>
<p>3.到/etc/pam.d/目录下,把rsh文件中的auth required /lib/security/pam_securetty.so<br>一行用“#”注释掉即可。（只有注释掉这一行，才能用root用户登录）</p>
<p><strong><code>例一</code>：将本地img文件夹内的所有内容 复制到服务器相应的img目录下</strong></p>
<pre><code class="bash"># -r 递归子目录
$ rcp -r img/* webserver1:/var/project/img/
</code></pre>
<p><strong><code>例二</code>：将服务器的img文件夹内的所有内容 复制到本地目录下</strong></p>
<pre><code class="bash"># -r 递归子目录
$ rcp -r webserver1:/var/project/img/* img/
</code></pre>
<p><strong><code>例三</code>：将目录复制到远程系统：要将本地目录及其文件和子目录复制到远程系统</strong></p>
<pre><code class="bash"># 将本地的img目录复制到服务器的project目录下
$ rcp -r img/ webserver1:/var/project/
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　rcp代表“remote file copy”（远程文件拷贝）。该命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>每天一个linux命令（43）: telnet命令</title>
    <link href="http://s.amlove.cn/2017/01/12/linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4%EF%BC%8843%EF%BC%89-telnet%E5%91%BD%E4%BB%A4/"/>
    <id>http://s.amlove.cn/2017/01/12/linux/每天一个linux命令（43）-telnet命令/</id>
    <published>2017-01-12T01:24:01.000Z</published>
    <updated>2017-03-13T04:11:01.644Z</updated>
    
    <content type="html"><![CDATA[<p>　　telnet命令通常用来远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。<br><a id="more"></a><br>　　但是，telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。</p>
<p>　　telnet命令还可做别的用途，比如确定远程服务的状态，比如确定远程服务器的某个端口是否能访问。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><pre><code class="bash">$ telnet [参数][主机]
</code></pre>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>　　执行telnet指令开启终端机阶段作业，并登入远端主机。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-8</td>
<td style="text-align:left">允许使用8位字符资料，包括输入与输出</td>
</tr>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">尝试自动登入远端系统</td>
</tr>
<tr>
<td style="text-align:left">-b&lt;主机别名&gt;</td>
<td style="text-align:left">使用别名指定远端主机名称</td>
</tr>
<tr>
<td style="text-align:left">-c</td>
<td style="text-align:left">不读取用户专属目录里的.telnetrc文件</td>
</tr>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">启动排错模式</td>
</tr>
<tr>
<td style="text-align:left">-e&lt;脱离字符&gt;</td>
<td style="text-align:left">设置脱离字符</td>
</tr>
<tr>
<td style="text-align:left">-E</td>
<td style="text-align:left">滤除脱离字符</td>
</tr>
<tr>
<td style="text-align:left">-f</td>
<td style="text-align:left">此参数的效果和指定”-F”参数相同</td>
</tr>
<tr>
<td style="text-align:left">-F</td>
<td style="text-align:left">使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机</td>
</tr>
<tr>
<td style="text-align:left">-k&lt;域名&gt;</td>
<td style="text-align:left">使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名</td>
</tr>
<tr>
<td style="text-align:left">-K</td>
<td style="text-align:left">不自动登入远端主机</td>
</tr>
<tr>
<td style="text-align:left">-l&lt;用户名称&gt;</td>
<td style="text-align:left">指定要登入远端主机的用户名称</td>
</tr>
<tr>
<td style="text-align:left">-L</td>
<td style="text-align:left">允许输出8位字符资料</td>
</tr>
<tr>
<td style="text-align:left">-n&lt;记录文件&gt;</td>
<td style="text-align:left">指定文件记录相关信息</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">使用类似rlogin指令的用户界面</td>
</tr>
<tr>
<td style="text-align:left">-S&lt;服务类型&gt;</td>
<td style="text-align:left">设置telnet连线所需的IP TOS信息</td>
</tr>
<tr>
<td style="text-align:left">-x</td>
<td style="text-align:left">假设主机有支持数据加密的功能，就使用它</td>
</tr>
<tr>
<td style="text-align:left">-X&lt;认证形态&gt;</td>
<td style="text-align:left">关闭指定的认证形态</td>
</tr>
</tbody>
</table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><strong><code>例一</code>：远程服务器无法访问</strong></p>
<pre><code class="bash">$ telnet 192.168.120.206
Trying 192.168.120.209...
telnet: connect to address 192.168.120.209: No route to host
telnet: Unable to connect to remote host: No route to host
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>处理这种情况方法：<br>　　（1）确认ip地址是否正确？<br>　　（2）确认ip地址对应的主机是否已经开机？<br>　　（3）如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看）<br>　　（4）如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行）<br>　　（5）如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）</p>
</blockquote>
<p><strong><code>例二</code>：域名无法解析</strong></p>
<pre><code class="bash">$ telnet www.baidu.com
www.baidu.com/telnet: Temporary failure in name resolution
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>处理这种情况方法：<br>　　（1）确认域名是否正确<br>　　（2）确认本机的域名解析有关的设置是否正确（/etc/resolv.conf中nameserver的设置是否正确，如果没有，可以使用nameserver 8.8.8.8）<br>　　（3）确认防火墙是否放开了UDP53端口的访问（DNS使用UDP协议，端口53，使用iptables-save查看）</p>
</blockquote>
<p><strong><code>例三</code>：连接被拒绝</strong></p>
<pre><code class="bash">$ telnet 192.168.120.206
Trying 192.168.120.206...
telnet: connect to address 192.168.120.206: Connection refused
telnet: Unable to connect to remote host: Connection refused
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>处理这种情况：<br>　　（1）确认ip地址或者主机名是否正确？<br>　　（2）确认端口是否正确，是否默认的23端口</p>
</blockquote>
<p><strong><code>例四</code>：正常telnet</strong></p>
<pre><code class="bash">$ telnet 192.168.120.204
Trying 192.168.120.204...
Connected to 192.168.120.204 (192.168.120.204).
Escape character is &#39;^]&#39;.

    localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1)

login: root
Password:
Login incorrect
</code></pre>
<blockquote>
<p><strong>说明：</strong><br>　　一般情况下不允许root从远程登录，可以先用普通账号登录，然后再用su -切到root用户。</p>
</blockquote>
<p><strong><code>例五</code>：测试服务器8888端口是否可用</strong></p>
<pre><code class="bash">$ telnet 192.168.0.88 8888
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　telnet命令通常用来远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://s.amlove.cn/categories/linux/"/>
    
    
      <category term="linux命令" scheme="http://s.amlove.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
